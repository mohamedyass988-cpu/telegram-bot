import time
import requests
import json
import re
import os
from datetime import datetime, date, timedelta
from urllib.parse import quote_plus
from pathlib import Path
import sqlite3
import telebot
from telebot import types
import threading
import random
import itertools
import threading
lock = threading.Lock()

def safe_get_setting(key):
    with lock:
        return get_setting(key)

def safe_set_setting(key, value):
    with lock:
        return set_setting(key, value)

API_URL = "https://maroon-wombat-183778.hostingersite.com/.o/OFFA_ivasms/api.php"
API_KEY = "sk_cc1480ac5e3a4818e07fb4b0674bc2a72228372220dba26ac4579cfd4eda903b"
USERNAME = "Ø­Ø· Ø­Ø³Ø§Ø¨ Ø§ÙŠÙØ§"
PASSWORD = "Ø¨Ø§Ø³ÙˆØ±Ø¯"
CACHE_FILE = "moran bot.json"

BOT_TOKEN = "8526935801:AAGqEAor9n91knVeDoTXF5mQdgqS_udPEY8"
CHAT_IDS = [
    "-1003510499114",
]
REFRESH_INTERVAL = 31
TIMEOUT = 50
MAX_RETRIES = 15
RETRY_DELAY = 5
IDX_DATE = 0
IDX_NUMBER = 2
IDX_SMS = 10
SENT_MESSAGES_FILE = "sent_messages.json"

ADMIN_IDS = [8590809949]
DB_PATH = "bot4.db"
FORCE_SUB_CHANNEL = None
FORCE_SUB_ENABLED = False
USER_AGREEMENTS = {}
if not BOT_TOKEN:
    raise SystemExit("âŒ BOT_TOKEN must be set in Secrets (Environment Variables)")
if not CHAT_IDS:
    raise SystemExit("âŒ CHAT_IDS must be configured")
if not USERNAME or not PASSWORD:
    print("âš ï¸  WARNING: SITE_USERNAME and SITE_PASSWORD not set in Secrets")
    print("âš ï¸  Bot will continue but login may fail")




COUNTRY_CODES = {
    "1": ("ğ”ğ’ğ€/ğ‚ğšğ§ğšğğš", "ã€ ğŸ‡ºğŸ‡¸ ã€", "ğ”ğ’ğ€/ğ‚ğ€ğğ€ğƒğ€"),
    "7": ("ğŠğšğ³ğšğ¤ğ¡ğ¬ğ­ğšğ§", "ã€ ğŸ‡°ğŸ‡¿ ã€", "ğŠğ€ğ™ğ€ğŠğ‡ğ’ğ“ğ€ğ"),
    "20": ("ğ„ğ ğ²ğ©ğ­", "ã€ ğŸ‡ªğŸ‡¬ ã€", "ğ„ğ†ğ˜ğğ“"),
    "27": ("ğ’ğ¨ğ®ğ­ğ¡ ğ€ğŸğ«ğ¢ğœğš", "ã€ ğŸ‡¿ğŸ‡¦ ã€", "ğ’ğğ”ğ“ğ‡ ğ€ğ…ğ‘ğˆğ‚ğ€"),
    "30": ("ğ†ğ«ğğğœğ", "ã€ ğŸ‡¬ğŸ‡· ã€", "ğ†ğ‘ğ„ğ„ğ‚ğ„"),
    "31": ("ğğğ­ğ¡ğğ«ğ¥ğšğ§ğğ¬", "ã€ ğŸ‡³ğŸ‡± ã€", "ğğ„ğ“ğ‡ğ„ğ‘ğ‹ğ€ğğƒğ’"),
    "32": ("ğğğ¥ğ ğ¢ğ®ğ¦", "ã€ ğŸ‡§ğŸ‡ª ã€", "ğğ„ğ‹ğ†ğˆğ”ğŒ"),
    "33": ("ğ…ğ«ğšğ§ğœğ", "ã€ ğŸ‡«ğŸ‡· ã€", "ğ…ğ‘ğ€ğğ‚ğ„"),
    "34": ("ğ’ğ©ğšğ¢ğ§", "ã€ ğŸ‡ªğŸ‡¸ ã€", "ğ’ğğ€ğˆğ"),
    "36": ("ğ‡ğ®ğ§ğ ğšğ«ğ²", "ã€ ğŸ‡­ğŸ‡º ã€", "ğ‡ğ”ğğ†ğ€ğ‘ğ˜"),
    "39": ("ğˆğ­ğšğ¥ğ²", "ã€ ğŸ‡®ğŸ‡¹ ã€", "ğˆğ“ğ€ğ‹ğ˜"),
    "40": ("ğ‘ğ¨ğ¦ğšğ§ğ¢ğš", "ã€ ğŸ‡·ğŸ‡´ ã€", "ğ‘ğğŒğ€ğğˆğ€"),
    "41": ("ğ’ğ°ğ¢ğ­ğ³ğğ«ğ¥ğšğ§ğ", "ã€ ğŸ‡¨ğŸ‡­ ã€", "ğ’ğ–ğˆğ“ğ™ğ„ğ‘ğ‹ğ€ğğƒ"),
    "43": ("ğ€ğ®ğ¬ğ­ğ«ğ¢ğš", "ã€ ğŸ‡¦ğŸ‡¹ ã€", "ğ€ğ”ğ’ğ“ğ‘ğˆğ€"),
    "44": ("ğ”ğŠ", "ã€ ğŸ‡¬ğŸ‡§ ã€", "ğ”ğŠ"),
    "45": ("ğƒğğ§ğ¦ğšğ«ğ¤", "ã€ ğŸ‡©ğŸ‡° ã€", "ğƒğ„ğğŒğ€ğ‘ğŠ"),
    "46": ("ğ’ğ°ğğğğ§", "ã€ ğŸ‡¸ğŸ‡ª ã€", "ğ’ğ–ğ„ğƒğ„ğ"),
    "47": ("ğğ¨ğ«ğ°ğšğ²", "ã€ ğŸ‡³ğŸ‡´ ã€", "ğğğ‘ğ–ğ€ğ˜"),
    "48": ("ğğ¨ğ¥ğšğ§ğ", "ã€ ğŸ‡µğŸ‡± ã€", "ğğğ‹ğ€ğğƒ"),
    "49": ("ğ†ğğ«ğ¦ğšğ§ğ²", "ã€ ğŸ‡©ğŸ‡ª ã€", "ğ†ğ„ğ‘ğŒğ€ğğ˜"),
    "51": ("ğğğ«ğ®", "ã€ ğŸ‡µğŸ‡ª ã€", "ğğ„ğ‘ğ”"),
    "52": ("ğŒğğ±ğ¢ğœğ¨", "ã€ ğŸ‡²ğŸ‡½ ã€", "ğŒğ„ğ—ğˆğ‚ğ"),
    "53": ("ğ‚ğ®ğ›ğš", "ã€ ğŸ‡¨ğŸ‡º ã€", "ğ‚ğ”ğğ€"),
    "54": ("ğ€ğ«ğ ğğ§ğ­ğ¢ğ§ğš", "ã€ ğŸ‡¦ğŸ‡· ã€", "ğ€ğ‘ğ†ğ„ğğ“ğˆğğ€"),
    "55": ("ğğ«ğšğ³ğ¢ğ¥", "ã€ ğŸ‡§ğŸ‡· ã€", "ğğ‘ğ€ğ™ğˆğ‹"),
    "56": ("ğ‚ğ¡ğ¢ğ¥ğ", "ã€ ğŸ‡¨ğŸ‡± ã€", "ğ‚ğ‡ğˆğ‹ğ„"),
    "57": ("ğ‚ğ¨ğ¥ğ¨ğ¦ğ›ğ¢ğš", "ã€ ğŸ‡¨ğŸ‡´ ã€", "ğ‚ğğ‹ğğŒğğˆğ€"),
    "58": ("ğ•ğğ§ğğ³ğ®ğğ¥ğš", "ã€ ğŸ‡»ğŸ‡ª ã€", "ğ•ğ„ğğ„ğ™ğ”ğ„ğ‹ğ€"),
    "60": ("ğŒğšğ¥ğšğ²ğ¬ğ¢ğš", "ã€ ğŸ‡²ğŸ‡¾ ã€", "ğŒğ€ğ‹ğ€ğ˜ğ’ğˆğ€"),
    "61": ("ğ€ğ®ğ¬ğ­ğ«ğšğ¥ğ¢ğš", "ã€ ğŸ‡¦ğŸ‡º ã€", "ğ€ğ”ğ’ğ“ğ‘ğ€ğ‹ğˆğ€"),
    "62": ("ğˆğ§ğğ¨ğ§ğğ¬ğ¢ğš", "ã€ ğŸ‡®ğŸ‡© ã€", "ğˆğğƒğğğ„ğ’ğˆğ€"),
    "63": ("ğğ¡ğ¢ğ¥ğ¢ğ©ğ©ğ¢ğ§ğğ¬", "ã€ ğŸ‡µğŸ‡­ ã€", "ğğ‡ğˆğ‹ğˆğğğˆğğ„ğ’"),
    "64": ("ğğğ° ğ™ğğšğ¥ğšğ§ğ", "ã€ ğŸ‡³ğŸ‡¿ ã€", "ğğ„ğ– ğ™ğ„ğ€ğ‹ğ€ğğƒ"),
    "65": ("ğ’ğ¢ğ§ğ ğšğ©ğ¨ğ«ğ", "ã€ ğŸ‡¸ğŸ‡¬ ã€", "ğ’ğˆğğ†ğ€ğğğ‘ğ„"),
    "66": ("ğ“ğ¡ğšğ¢ğ¥ğšğ§ğ", "ã€ ğŸ‡¹ğŸ‡­ ã€", "ğ“ğ‡ğ€ğˆğ‹ğ€ğğƒ"),
    "81": ("ğ‰ğšğ©ğšğ§", "ã€ ğŸ‡¯ğŸ‡µ ã€", "ğ‰ğ€ğğ€ğ"),
    "82": ("ğ’ğ¨ğ®ğ­ğ¡ ğŠğ¨ğ«ğğš", "ã€ ğŸ‡°ğŸ‡· ã€", "ğ’ğğ”ğ“ğ‡ ğŠğğ‘ğ„ğ€"),
    "84": ("ğ•ğ¢ğğ­ğ§ğšğ¦", "ã€ ğŸ‡»ğŸ‡³ ã€", "ğ•ğˆğ„ğ“ğğ€ğŒ"),
    "86": ("ğ‚ğ¡ğ¢ğ§ğš", "ã€ ğŸ‡¨ğŸ‡³ ã€", "ğ‚ğ‡ğˆğğ€"),
    "90": ("ğ“ğ®ğ«ğ¤ğğ²", "ã€ ğŸ‡¹ğŸ‡· ã€", "ğ“ğ”ğ‘ğŠğ„ğ˜"),
    "91": ("ğˆğ§ğğ¢ğš", "ã€ ğŸ‡®ğŸ‡³ ã€", "ğˆğğƒğˆğ€"),
    "92": ("ğğšğ¤ğ¢ğ¬ğ­ğšğ§", "ã€ ğŸ‡µğŸ‡° ã€", "ğğ€ğŠğˆğ’ğ“ğ€ğ"),
    "93": ("ğ€ğŸğ ğ¡ğšğ§ğ¢ğ¬ğ­ğšğ§", "ã€ ğŸ‡¦ğŸ‡« ã€", "ğ€ğ…ğ†ğ‡ğ€ğğˆğ’ğ“ğ€ğ"),
    "94": ("ğ’ğ«ğ¢ ğ‹ğšğ§ğ¤ğš", "ã€ ğŸ‡±ğŸ‡° ã€", "ğ’ğ‘ğˆ ğ‹ğ€ğğŠğ€"),
    "95": ("ğŒğ²ğšğ§ğ¦ğšğ«", "ã€ ğŸ‡²ğŸ‡² ã€", "ğŒğ˜ğ€ğğŒğ€ğ‘"),
    "98": ("ğˆğ«ğšğ§", "ã€ ğŸ‡®ğŸ‡· ã€", "ğˆğ‘ğ€ğ"),
    "211": ("ğ’ğ¨ğ®ğ­ğ¡ ğ’ğ®ğğšğ§", "ã€ ğŸ‡¸ğŸ‡¸ ã€", "ğ’ğğ”ğ“ğ‡ ğ’ğ”ğƒğ€ğ"),
    "212": ("ğŒğ¨ğ«ğ¨ğœğœğ¨", "ã€ ğŸ‡²ğŸ‡¦ ã€", "ğŒğğ‘ğğ‚ğ‚ğ"),
    "213": ("ğ€ğ¥ğ ğğ«ğ¢ğš", "ã€ ğŸ‡©ğŸ‡¿ ã€", "ğ€ğ‹ğ†ğ„ğ‘ğˆğ€"),
    "216": ("ğ“ğ®ğ§ğ¢ğ¬ğ¢ğš", "ã€ ğŸ‡¹ğŸ‡³ ã€", "ğ“ğ”ğğˆğ’ğˆğ€"),
    "218": ("ğ‹ğ¢ğ›ğ²ğš", "ã€ ğŸ‡±ğŸ‡¾ ã€", "ğ‹ğˆğğ˜ğ€"),
    "220": ("ğ†ğšğ¦ğ›ğ¢ğš", "ã€ ğŸ‡¬ğŸ‡² ã€", "ğ†ğ€ğŒğğˆğ€"),
    "221": ("ğ’ğğ§ğğ ğšğ¥", "ã€ ğŸ‡¸ğŸ‡³ ã€", "ğ’ğ„ğğ„ğ†ğ€ğ‹"),
    "222": ("ğŒğšğ®ğ«ğ¢ğ­ğšğ§ğ¢ğš", "ã€ ğŸ‡²ğŸ‡· ã€", "ğŒğ€ğ”ğ‘ğˆğ“ğ€ğğˆğ€"),
    "223": ("ğŒğšğ¥ğ¢", "ã€ ğŸ‡²ğŸ‡± ã€", "ğŒğ€ğ‹ğˆ"),
    "224": ("ğ†ğ®ğ¢ğ§ğğš", "ã€ ğŸ‡¬ğŸ‡³ ã€", "ğ†ğ”ğˆğğ„ğ€"),
    "225": ("ğˆğ¯ğ¨ğ«ğ² ğ‚ğ¨ğšğ¬ğ­", "ã€ ğŸ‡¨ğŸ‡® ã€", "ğˆğ•ğğ‘ğ˜ ğ‚ğğ€ğ’ğ“"),
    "226": ("ğğ®ğ«ğ¤ğ¢ğ§ğš ğ…ğšğ¬ğ¨", "ã€ ğŸ‡§ğŸ‡« ã€", "ğğ”ğ‘ğŠğˆğğ€ ğ…ğ€ğ’ğ"),
    "227": ("ğğ¢ğ ğğ«", "ã€ ğŸ‡³ğŸ‡ª ã€", "ğğˆğ†ğ„ğ‘"),
    "228": ("ğ“ğ¨ğ ğ¨", "ã€ ğŸ‡¹ğŸ‡¬ ã€", "ğ“ğğ†ğ"),
    "229": ("ğğğ§ğ¢ğ§", "ã€ ğŸ‡§ğŸ‡¯ ã€", "ğğ„ğğˆğ"),
    "230": ("ğŒğšğ®ğ«ğ¢ğ­ğ¢ğ®ğ¬", "ã€ ğŸ‡²ğŸ‡º ã€", "ğŒğ€ğ”ğ‘ğˆğ“ğˆğ”ğ’"),
    "231": ("ğ‹ğ¢ğ›ğğ«ğ¢ğš", "ã€ ğŸ‡±ğŸ‡· ã€", "ğ‹ğˆğğ„ğ‘ğˆğ€"),
    "232": ("ğ’ğ¢ğğ«ğ«ğš ğ‹ğğ¨ğ§ğ", "ã€ ğŸ‡¸ğŸ‡± ã€", "ğ’ğˆğ„ğ‘ğ‘ğ€ ğ‹ğ„ğğğ„"),
    "233": ("ğ†ğ¡ğšğ§ğš", "ã€ ğŸ‡¬ğŸ‡­ ã€", "ğ†ğ‡ğ€ğğ€"),
    "234": ("ğğ¢ğ ğğ«ğ¢ğš", "ã€ ğŸ‡³ğŸ‡¬ ã€", "ğğˆğ†ğ„ğ‘ğˆğ€"),
    "235": ("ğ‚ğ¡ğšğ", "ã€ ğŸ‡¹ğŸ‡© ã€", "ğ‚ğ‡ğ€ğƒ"),
    "236": ("ğ‚ğ€ğ‘", "ã€ ğŸ‡¨ğŸ‡« ã€", "ğ‚ğ„ğğ“ğ‘ğ€ğ‹ ğ€ğ…ğ‘ğˆğ‚ğ€ğ ğ‘ğ„ğ"),
    "237": ("ğ‚ğšğ¦ğğ«ğ¨ğ¨ğ§", "ã€ ğŸ‡¨ğŸ‡² ã€", "ğ‚ğ€ğŒğ„ğ‘ğğğ"),
    "238": ("ğ‚ğšğ©ğ ğ•ğğ«ğğ", "ã€ ğŸ‡¨ğŸ‡» ã€", "ğ‚ğ€ğğ„ ğ•ğ„ğ‘ğƒğ„"),
    "239": ("ğ’ğšğ¨ ğ“ğ¨ğ¦ğ", "ã€ ğŸ‡¸ğŸ‡¹ ã€", "ğ’ğ€ğ ğ“ğğŒğ„"),
    "240": ("ğ„ğª. ğ†ğ®ğ¢ğ§ğğš", "ã€ ğŸ‡¬ğŸ‡¶ ã€", "ğ„ğğ”ğ€ğ“ğğ‘ğˆğ€ğ‹ ğ†ğ”ğˆğğ„ğ€"),
    "241": ("ğ†ğšğ›ğ¨ğ§", "ã€ ğŸ‡¬ğŸ‡¦ ã€", "ğ†ğ€ğğğ"),
    "242": ("ğ‚ğ¨ğ§ğ ğ¨", "ã€ ğŸ‡¨ğŸ‡¬ ã€", "ğ‚ğğğ†ğ"),
    "243": ("ğƒğ‘ ğ‚ğ¨ğ§ğ ğ¨", "ã€ ğŸ‡¨ğŸ‡© ã€", "ğƒğ‘ ğ‚ğğğ†ğ"),
    "244": ("ğ€ğ§ğ ğ¨ğ¥ğš", "ã€ ğŸ‡¦ğŸ‡´ ã€", "ğ€ğğ†ğğ‹ğ€"),
    "245": ("ğ†ğ®ğ¢ğ§ğğš-ğğ¢ğ¬ğ¬ğšğ®", "ã€ ğŸ‡¬ğŸ‡¼ ã€", "ğ†ğ”ğˆğğ„ğ€-ğğˆğ’ğ’ğ€ğ”"),
    "248": ("ğ’ğğ²ğœğ¡ğğ¥ğ¥ğğ¬", "ã€ ğŸ‡¸ğŸ‡¨ ã€", "ğ’ğ„ğ˜ğ‚ğ‡ğ„ğ‹ğ‹ğ„ğ’"),
    "249": ("ğ’ğ®ğğšğ§", "ã€ ğŸ‡¸ğŸ‡© ã€", "ğ’ğ”ğƒğ€ğ"),
    "250": ("ğ‘ğ°ğšğ§ğğš", "ã€ ğŸ‡·ğŸ‡¼ ã€", "ğ‘ğ–ğ€ğğƒğ€"),
    "251": ("ğ„ğ­ğ¡ğ¢ğ¨ğ©ğ¢ğš", "ã€ ğŸ‡ªğŸ‡¹ ã€", "ğ„ğ“ğ‡ğˆğğğˆğ€"),
    "252": ("ğ’ğ¨ğ¦ğšğ¥ğ¢ğš", "ã€ ğŸ‡¸ğŸ‡´ ã€", "ğ’ğğŒğ€ğ‹ğˆğ€"),
    "253": ("ğƒğ£ğ¢ğ›ğ¨ğ®ğ­ğ¢", "ã€ ğŸ‡©ğŸ‡¯ ã€", "ğƒğ‰ğˆğğğ”ğ“ğˆ"),
    "254": ("ğŠğğ§ğ²ğš", "ã€ ğŸ‡°ğŸ‡ª ã€", "ğŠğ„ğğ˜ğ€"),
    "255": ("ğ“ğšğ§ğ³ğšğ§ğ¢ğš", "ã€ ğŸ‡¹ğŸ‡¿ ã€", "ğ“ğ€ğğ™ğ€ğğˆğ€"),
    "256": ("ğ”ğ ğšğ§ğğš", "ã€ ğŸ‡ºğŸ‡¬ ã€", "ğ”ğ†ğ€ğğƒğ€"),
    "257": ("ğğ®ğ«ğ®ğ§ğğ¢", "ã€ ğŸ‡§ğŸ‡® ã€", "ğğ”ğ‘ğ”ğğƒğˆ"),
    "258": ("ğŒğ¨ğ³ğšğ¦ğ›ğ¢ğªğ®ğ", "ã€ ğŸ‡²ğŸ‡¿ ã€", "ğŒğğ™ğ€ğŒğğˆğğ”ğ„"),
    "260": ("ğ™ğšğ¦ğ›ğ¢ğš", "ã€ ğŸ‡¿ğŸ‡² ã€", "ğ™ğ€ğŒğğˆğ€"),
    "261": ("ğŒğšğğšğ ğšğ¬ğœğšğ«", "ã€ ğŸ‡²ğŸ‡¬ ã€", "ğŒğ€ğƒğ€ğ†ğ€ğ’ğ‚ğ€ğ‘"),
    "262": ("ğ‘ğğ®ğ§ğ¢ğ¨ğ§", "ã€ ğŸ‡·ğŸ‡ª ã€", "ğ‘ğ„ğ”ğğˆğğ"),
    "263": ("ğ™ğ¢ğ¦ğ›ğšğ›ğ°ğ", "ã€ ğŸ‡¿ğŸ‡¼ ã€", "ğ™ğˆğŒğğ€ğğ–ğ„"),
    "264": ("ğğšğ¦ğ¢ğ›ğ¢ğš", "ã€ ğŸ‡³ğŸ‡¦ ã€", "ğğ€ğŒğˆğğˆğ€"),
    "265": ("ğŒğšğ¥ğšğ°ğ¢", "ã€ ğŸ‡²ğŸ‡¼ ã€", "ğŒğ€ğ‹ğ€ğ–ğˆ"),
    "266": ("ğ‹ğğ¬ğ¨ğ­ğ¡ğ¨", "ã€ ğŸ‡±ğŸ‡¸ ã€", "ğ‹ğ„ğ’ğğ“ğ‡ğ"),
    "267": ("ğğ¨ğ­ğ¬ğ°ğšğ§ğš", "ã€ ğŸ‡§ğŸ‡¼ ã€", "ğğğ“ğ’ğ–ğ€ğğ€"),
    "268": ("ğ„ğ¬ğ°ğšğ­ğ¢ğ§ğ¢", "ã€ ğŸ‡¸ğŸ‡¿ ã€", "ğ„ğ’ğ–ğ€ğ“ğˆğğˆ"),
    "269": ("ğ‚ğ¨ğ¦ğ¨ğ«ğ¨ğ¬", "ã€ ğŸ‡°ğŸ‡² ã€", "ğ‚ğğŒğğ‘ğğ’"),
    "350": ("ğ†ğ¢ğ›ğ«ğšğ¥ğ­ğšğ«", "ã€ ğŸ‡¬ğŸ‡® ã€", "ğ†ğˆğğ‘ğ€ğ‹ğ“ğ€ğ‘"),
    "351": ("ğğ¨ğ«ğ­ğ®ğ ğšğ¥", "ã€ ğŸ‡µğŸ‡¹ ã€", "ğğğ‘ğ“ğ”ğ†ğ€ğ‹"),
    "352": ("ğ‹ğ®ğ±ğğ¦ğ›ğ¨ğ®ğ«ğ ", "ã€ ğŸ‡±ğŸ‡º ã€", "ğ‹ğ”ğ—ğ„ğŒğğğ”ğ‘ğ†"),
    "353": ("ğˆğ«ğğ¥ğšğ§ğ", "ã€ ğŸ‡®ğŸ‡ª ã€", "ğˆğ‘ğ„ğ‹ğ€ğğƒ"),
    "354": ("ğˆğœğğ¥ğšğ§ğ", "ã€ ğŸ‡®ğŸ‡¸ ã€", "ğˆğ‚ğ„ğ‹ğ€ğğƒ"),
    "355": ("ğ€ğ¥ğ›ğšğ§ğ¢ğš", "ã€ ğŸ‡¦ğŸ‡± ã€", "ğ€ğ‹ğğ€ğğˆğ€"),
    "356": ("ğŒğšğ¥ğ­ğš", "ã€ ğŸ‡²ğŸ‡¹ ã€", "ğŒğ€ğ‹ğ“ğ€"),
    "357": ("ğ‚ğ²ğ©ğ«ğ®ğ¬", "ã€ ğŸ‡¨ğŸ‡¾ ã€", "ğ‚ğ˜ğğ‘ğ”ğ’"),
    "358": ("ğ…ğ¢ğ§ğ¥ğšğ§ğ", "ã€ ğŸ‡«ğŸ‡® ã€", "ğ…ğˆğğ‹ğ€ğğƒ"),
    "359": ("ğğ®ğ¥ğ ğšğ«ğ¢ğš", "ã€ ğŸ‡§ğŸ‡¬ ã€", "ğğ”ğ‹ğ†ğ€ğ‘ğˆğ€"),
    "370": ("ğ‹ğ¢ğ­ğ¡ğ®ğšğ§ğ¢ğš", "ã€ ğŸ‡±ğŸ‡¹ ã€", "ğ‹ğˆğ“ğ‡ğ”ğ€ğğˆğ€"),
    "371": ("ğ‹ğšğ­ğ¯ğ¢ğš", "ã€ ğŸ‡±ğŸ‡» ã€", "ğ‹ğ€ğ“ğ•ğˆğ€"),
    "372": ("ğ„ğ¬ğ­ğ¨ğ§ğ¢ğš", "ã€ ğŸ‡ªğŸ‡ª ã€", "ğ„ğ’ğ“ğğğˆğ€"),
    "373": ("ğŒğ¨ğ¥ğğ¨ğ¯ğš", "ã€ ğŸ‡²ğŸ‡© ã€", "ğŒğğ‹ğƒğğ•ğ€"),
    "374": ("ğ€ğ«ğ¦ğğ§ğ¢ğš", "ã€ ğŸ‡¦ğŸ‡² ã€", "ğ€ğ‘ğŒğ„ğğˆğ€"),
    "375": ("ğğğ¥ğšğ«ğ®ğ¬", "ã€ ğŸ‡§ğŸ‡¾ ã€", "ğğ„ğ‹ğ€ğ‘ğ”ğ’"),
    "376": ("ğ€ğ§ğğ¨ğ«ğ«ğš", "ã€ ğŸ‡¦ğŸ‡© ã€", "ğ€ğğƒğğ‘ğ‘ğ€"),
    "377": ("ğŒğ¨ğ§ğšğœğ¨", "ã€ ğŸ‡²ğŸ‡¨ ã€", "ğŒğğğ€ğ‚ğ"),
    "378": ("ğ’ğšğ§ ğŒğšğ«ğ¢ğ§ğ¨", "ã€ ğŸ‡¸ğŸ‡² ã€", "ğ’ğ€ğ ğŒğ€ğ‘ğˆğğ"),
    "380": ("ğ”ğ¤ğ«ğšğ¢ğ§ğ", "ã€ ğŸ‡ºğŸ‡¦ ã€", "ğ”ğŠğ‘ğ€ğˆğğ„"),
    "381": ("ğ’ğğ«ğ›ğ¢ğš", "ã€ ğŸ‡·ğŸ‡¸ ã€", "ğ’ğ„ğ‘ğğˆğ€"),
    "382": ("ğŒğ¨ğ§ğ­ğğ§ğğ ğ«ğ¨", "ã€ ğŸ‡²ğŸ‡ª ã€", "ğŒğğğ“ğ„ğğ„ğ†ğ‘ğ"),
    "383": ("ğŠğ¨ğ¬ğ¨ğ¯ğ¨", "ã€ ğŸ‡½ğŸ‡° ã€", "ğŠğğ’ğğ•ğ"),
    "385": ("ğ‚ğ«ğ¨ğšğ­ğ¢ğš", "ã€ ğŸ‡­ğŸ‡· ã€", "ğ‚ğ‘ğğ€ğ“ğˆğ€"),
    "386": ("ğ’ğ¥ğ¨ğ¯ğğ§ğ¢ğš", "ã€ ğŸ‡¸ğŸ‡® ã€", "ğ’ğ‹ğğ•ğ„ğğˆğ€"),
    "387": ("ğğ¨ğ¬ğ§ğ¢ğš", "ã€ ğŸ‡§ğŸ‡¦ ã€", "ğğğ’ğğˆğ€"),
    "389": ("ğ. ğŒğšğœğğğ¨ğ§ğ¢ğš", "ã€ ğŸ‡²ğŸ‡° ã€", "ğğğ‘ğ“ğ‡ ğŒğ€ğ‚ğ„ğƒğğğˆğ€"),
    "420": ("ğ‚ğ³ğğœğ¡ ğ‘ğğ©", "ã€ ğŸ‡¨ğŸ‡¿ ã€", "ğ‚ğ™ğ„ğ‚ğ‡ ğ‘ğ„ğğ”ğğ‹ğˆğ‚"),
    "421": ("ğ’ğ¥ğ¨ğ¯ğšğ¤ğ¢ğš", "ã€ ğŸ‡¸ğŸ‡° ã€", "ğ’ğ‹ğğ•ğ€ğŠğˆğ€"),
    "423": ("ğ‹ğ¢ğğœğ¡ğ­ğğ§ğ¬ğ­ğğ¢ğ§", "ã€ ğŸ‡±ğŸ‡® ã€", "ğ‹ğˆğ„ğ‚ğ‡ğ“ğ„ğğ’ğ“ğ„ğˆğ"),
    "500": ("ğ…ğšğ¥ğ¤ğ¥ğšğ§ğ", "ã€ ğŸ‡«ğŸ‡° ã€", "ğ…ğ€ğ‹ğŠğ‹ğ€ğğƒ ğˆğ’ğ‹ğ€ğğƒğ’"),
    "501": ("ğğğ¥ğ¢ğ³ğ", "ã€ ğŸ‡§ğŸ‡¿ ã€", "ğğ„ğ‹ğˆğ™ğ„"),
    "502": ("ğ†ğ®ğšğ­ğğ¦ğšğ¥ğš", "ã€ ğŸ‡¬ğŸ‡¹ ã€", "ğ†ğ”ğ€ğ“ğ„ğŒğ€ğ‹ğ€"),
    "503": ("ğ„ğ¥ ğ’ğšğ¥ğ¯ğšğğ¨ğ«", "ã€ ğŸ‡¸ğŸ‡» ã€", "ğ„ğ‹ ğ’ğ€ğ‹ğ•ğ€ğƒğğ‘"),
    "504": ("ğ‡ğ¨ğ§ğğ®ğ«ğšğ¬", "ã€ ğŸ‡­ğŸ‡³ ã€", "ğ‡ğğğƒğ”ğ‘ğ€ğ’"),
    "505": ("ğğ¢ğœğšğ«ğšğ ğ®ğš", "ã€ ğŸ‡³ğŸ‡® ã€", "ğğˆğ‚ğ€ğ‘ğ€ğ†ğ”ğ€"),
    "506": ("ğ‚ğ¨ğ¬ğ­ğš ğ‘ğ¢ğœğš", "ã€ ğŸ‡¨ğŸ‡· ã€", "ğ‚ğğ’ğ“ğ€ ğ‘ğˆğ‚ğ€"),
    "507": ("ğğšğ§ğšğ¦ğš", "ã€ ğŸ‡µğŸ‡¦ ã€", "ğğ€ğğ€ğŒğ€"),
    "509": ("ğ‡ğšğ¢ğ­ğ¢", "ã€ ğŸ‡­ğŸ‡¹ ã€", "ğ‡ğ€ğˆğ“ğˆ"),
    "591": ("ğğ¨ğ¥ğ¢ğ¯ğ¢ğš", "ã€ ğŸ‡§ğŸ‡´ ã€", "ğğğ‹ğˆğ•ğˆğ€"),
    "592": ("ğ†ğ®ğ²ğšğ§ğš", "ã€ ğŸ‡¬ğŸ‡¾ ã€", "ğ†ğ”ğ˜ğ€ğğ€"),
    "593": ("ğ„ğœğ®ğšğğ¨ğ«", "ã€ ğŸ‡ªğŸ‡¨ ã€", "ğ„ğ‚ğ”ğ€ğƒğğ‘"),
    "595": ("ğğšğ«ğšğ ğ®ğšğ²", "ã€ ğŸ‡µğŸ‡¾ ã€", "ğğ€ğ‘ğ€ğ†ğ”ğ€ğ˜"),
    "597": ("ğ’ğ®ğ«ğ¢ğ§ğšğ¦ğ", "ã€ ğŸ‡¸ğŸ‡· ã€", "ğ’ğ”ğ‘ğˆğğ€ğŒğ„"),
    "598": ("ğ”ğ«ğ®ğ ğ®ğšğ²", "ã€ ğŸ‡ºğŸ‡¾ ã€", "ğ”ğ‘ğ”ğ†ğ”ğ€ğ˜"),
    "670": ("ğ“ğ¢ğ¦ğ¨ğ«-ğ‹ğğ¬ğ­ğ", "ã€ ğŸ‡¹ğŸ‡± ã€", "ğ“ğˆğŒğğ‘-ğ‹ğ„ğ’ğ“ğ„"),
    "673": ("ğğ«ğ®ğ§ğğ¢", "ã€ ğŸ‡§ğŸ‡³ ã€", "ğğ‘ğ”ğğ„ğˆ"),
    "674": ("ğğšğ®ğ«ğ®", "ã€ ğŸ‡³ğŸ‡· ã€", "ğğ€ğ”ğ‘ğ”"),
    "675": ("ğğğ†", "ã€ ğŸ‡µğŸ‡¬ ã€", "ğğ€ğğ”ğ€ ğğ„ğ– ğ†ğ”ğˆğğ„ğ€"),
    "676": ("ğ“ğ¨ğ§ğ ğš", "ã€ ğŸ‡¹ğŸ‡´ ã€", "ğ“ğğğ†ğ€"),
    "677": ("ğ’ğ¨ğ¥ğ¨ğ¦ğ¨ğ§ ğˆğ¬", "ã€ ğŸ‡¸ğŸ‡§ ã€", "ğ’ğğ‹ğğŒğğ ğˆğ’ğ‹ğ€ğğƒğ’"),
    "678": ("ğ•ğšğ§ğ®ğšğ­ğ®", "ã€ ğŸ‡»ğŸ‡º ã€", "ğ•ğ€ğğ”ğ€ğ“ğ”"),
    "679": ("ğ…ğ¢ğ£ğ¢", "ã€ ğŸ‡«ğŸ‡¯ ã€", "ğ…ğˆğ‰ğˆ"),
    "680": ("ğğšğ¥ğšğ®", "ã€ ğŸ‡µğŸ‡¼ ã€", "ğğ€ğ‹ğ€ğ”"),
    "685": ("ğ’ğšğ¦ğ¨ğš", "ã€ ğŸ‡¼ğŸ‡¸ ã€", "ğ’ğ€ğŒğğ€"),
    "686": ("ğŠğ¢ğ«ğ¢ğ›ğšğ­ğ¢", "ã€ ğŸ‡°ğŸ‡® ã€", "ğŠğˆğ‘ğˆğğ€ğ“ğˆ"),
    "687": ("ğğğ° ğ‚ğšğ¥ğğğ¨ğ§ğ¢ğš", "ã€ ğŸ‡³ğŸ‡¨ ã€", "ğğ„ğ– ğ‚ğ€ğ‹ğ„ğƒğğğˆğ€"),
    "688": ("ğ“ğ®ğ¯ğšğ¥ğ®", "ã€ ğŸ‡¹ğŸ‡» ã€", "ğ“ğ”ğ•ğ€ğ‹ğ”"),
    "689": ("ğ…ğ« ğğ¨ğ¥ğ²ğ§ğğ¬ğ¢ğš", "ã€ ğŸ‡µğŸ‡« ã€", "ğ…ğ‘ğ„ğğ‚ğ‡ ğğğ‹ğ˜ğğ„ğ’ğˆğ€"),
    "691": ("ğŒğ¢ğœğ«ğ¨ğ§ğğ¬ğ¢ğš", "ã€ ğŸ‡«ğŸ‡² ã€", "ğŒğˆğ‚ğ‘ğğğ„ğ’ğˆğ€"),
    "692": ("ğŒğšğ«ğ¬ğ¡ğšğ¥ğ¥ ğˆğ¬", "ã€ ğŸ‡²ğŸ‡­ ã€", "ğŒğ€ğ‘ğ’ğ‡ğ€ğ‹ğ‹ ğˆğ’ğ‹ğ€ğğƒğ’"),
    "850": ("ğğ¨ğ«ğ­ğ¡ ğŠğ¨ğ«ğğš", "ã€ ğŸ‡°ğŸ‡µ ã€", "ğğğ‘ğ“ğ‡ ğŠğğ‘ğ„ğ€"),
    "852": ("ğ‡ğ¨ğ§ğ  ğŠğ¨ğ§ğ ", "ã€ ğŸ‡­ğŸ‡° ã€", "ğ‡ğğğ† ğŠğğğ†"),
    "853": ("ğŒğšğœğšğ®", "ã€ ğŸ‡²ğŸ‡´ ã€", "ğŒğ€ğ‚ğ€ğ”"),
    "855": ("ğ‚ğšğ¦ğ›ğ¨ğğ¢ğš", "ã€ ğŸ‡°ğŸ‡­ ã€", "ğ‚ğ€ğŒğğğƒğˆğ€"),
    "856": ("ğ‹ğšğ¨ğ¬", "ã€ ğŸ‡±ğŸ‡¦ ã€", "ğ‹ğ€ğğ’"),
    "960": ("ğŒğšğ¥ğğ¢ğ¯ğğ¬", "ã€ ğŸ‡²ğŸ‡» ã€", "ğŒğ€ğ‹ğƒğˆğ•ğ„ğ’"),
    "961": ("ğ‹ğğ›ğšğ§ğ¨ğ§", "ã€ ğŸ‡±ğŸ‡§ ã€", "ğ‹ğ„ğğ€ğğğ"),
    "962": ("ğ‰ğ¨ğ«ğğšğ§", "ã€ ğŸ‡¯ğŸ‡´ ã€", "ğ‰ğğ‘ğƒğ€ğ"),
    "963": ("ğ’ğ²ğ«ğ¢ğš", "ã€ ğŸ‡¸ğŸ‡¾ ã€", "ğ’ğ˜ğ‘ğˆğ€"),
    "964": ("ğˆğ«ğšğª", "ã€ ğŸ‡®ğŸ‡¶ ã€", "ğˆğ‘ğ€ğ"),
    "965": ("ğŠğ®ğ°ğšğ¢ğ­", "ã€ ğŸ‡°ğŸ‡¼ ã€", "ğŠğ”ğ–ğ€ğˆğ“"),
    "966": ("ğ’ğšğ®ğğ¢ ğ€ğ«ğšğ›ğ¢ğš", "ã€ ğŸ‡¸ğŸ‡¦ ã€", "ğ’ğ€ğ”ğƒğˆ ğ€ğ‘ğ€ğğˆğ€"),
    "967": ("ğ˜ğğ¦ğğ§", "ã€ ğŸ‡¾ğŸ‡ª ã€", "ğ˜ğ„ğŒğ„ğ"),
    "968": ("ğğ¦ğšğ§", "ã€ ğŸ‡´ğŸ‡² ã€", "ğğŒğ€ğ"),
    "970": ("ğğšğ¥ğğ¬ğ­ğ¢ğ§ğ", "ã€ ğŸ‡µğŸ‡¸ ã€", "ğğ€ğ‹ğ„ğ’ğ“ğˆğğ„"),
    "971": ("ğ”ğ€ğ„", "ã€ ğŸ‡¦ğŸ‡ª ã€", "ğ”ğ€ğ„"),
    "972": ("ğ€ğ™ğ‘ğ€ğğˆğ‹", "ã€ ğŸ¤®ğŸŒ ã€", "ğ€ğ™ğ‘ğ€ğğˆğ‹"),
    "973": ("ğğšğ¡ğ«ğšğ¢ğ§", "ã€ ğŸ‡§ğŸ‡­ ã€", "ğğ€ğ‡ğ‘ğ€ğˆğ"),
    "974": ("ğğšğ­ğšğ«", "ã€ ğŸ‡¶ğŸ‡¦ ã€", "ğğ€ğ“ğ€ğ‘"),
    "975": ("ğğ¡ğ®ğ­ğšğ§", "ã€ ğŸ‡§ğŸ‡¹ ã€", "ğğ‡ğ”ğ“ğ€ğ"),
    "976": ("ğŒğ¨ğ§ğ ğ¨ğ¥ğ¢ğš", "ã€ ğŸ‡²ğŸ‡³ ã€", "ğŒğğğ†ğğ‹ğˆğ€"),
    "977": ("ğğğ©ğšğ¥", "ã€ ğŸ‡³ğŸ‡µ ã€", "ğğ„ğğ€ğ‹"),
    "992": ("ğ“ğšğ£ğ¢ğ¤ğ¢ğ¬ğ­ğšğ§", "ã€ ğŸ‡¹ğŸ‡¯ ã€", "ğ“ğ€ğ‰ğˆğŠğˆğ’ğ“ğ€ğ"),
    "993": ("ğ“ğ®ğ«ğ¤ğ¦ğğ§ğ¢ğ¬ğ­ğšğ§", "ã€ ğŸ‡¹ğŸ‡² ã€", "ğ“ğ”ğ‘ğŠğŒğ„ğğˆğ’ğ“ğ€ğ"),
    "994": ("ğ€ğ³ğğ«ğ›ğšğ¢ğ£ğšğ§", "ã€ ğŸ‡¦ğŸ‡¿ ã€", "ğ€ğ™ğ„ğ‘ğğ€ğˆğ‰ğ€ğ"),
    "995": ("ğ†ğğ¨ğ«ğ ğ¢ğš", "ã€ ğŸ‡¬ğŸ‡ª ã€", "ğ†ğ„ğğ‘ğ†ğˆğ€"),
    "996": ("ğŠğ²ğ«ğ ğ²ğ³ğ¬ğ­ğšğ§", "ã€ ğŸ‡°ğŸ‡¬ ã€", "ğŠğ˜ğ‘ğ†ğ˜ğ™ğ’ğ“ğ€ğ"),
    "998": ("ğ”ğ³ğ›ğğ¤ğ¢ğ¬ğ­ğšğ§", "ã€ ğŸ‡ºğŸ‡¿ ã€", "ğ”ğ™ğğ„ğŠğˆğ’ğ“ğ€ğ"),
}



def get_setting(key):
    conn = sqlite3.connect(DB_PATH)
    c = conn.cursor()
    c.execute("SELECT value FROM bot_settings WHERE key=?", (key,))
    row = c.fetchone()
    conn.close()
    return row[0] if row else None

def set_setting(key, value):
    conn = sqlite3.connect(DB_PATH)
    c = conn.cursor()
    c.execute("REPLACE INTO bot_settings (key, value) VALUES (?, ?)", (key, value))
    conn.commit()
    conn.close()



def init_db():
    conn = sqlite3.connect(DB_PATH)
    c = conn.cursor()
    c.execute('''
        CREATE TABLE IF NOT EXISTS users (
            user_id INTEGER PRIMARY KEY,
            username TEXT,
            first_name TEXT,
            last_name TEXT,
            country_code TEXT,
            assigned_number TEXT,
            is_banned INTEGER DEFAULT 0,
            private_combo_country TEXT DEFAULT NULL
        )
    ''')
    c.execute('''
        CREATE TABLE IF NOT EXISTS combos (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            country_code TEXT UNIQUE,
            numbers TEXT
        )
    ''')
    c.execute('''
        CREATE TABLE IF NOT EXISTS otp_logs (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            number TEXT,
            otp TEXT,
            full_message TEXT,
            timestamp TEXT,
            assigned_to INTEGER
        )
    ''')
    c.execute('''
        CREATE TABLE IF NOT EXISTS dashboards (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            base_url TEXT,
            ajax_path TEXT,
            login_page TEXT,
            login_post TEXT,
            username TEXT,
            password TEXT
        )
    ''')
    c.execute('''
        CREATE TABLE IF NOT EXISTS bot_settings (
            key TEXT PRIMARY KEY,
            value TEXT
        )
    ''')
    c.execute('''
        CREATE TABLE IF NOT EXISTS private_combos (
            user_id INTEGER,
            country_code TEXT,
            numbers TEXT,
            PRIMARY KEY (user_id, country_code)
        )
    ''')

    c.execute('''
        CREATE TABLE IF NOT EXISTS force_sub_channels (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            channel_url TEXT UNIQUE NOT NULL,
            description TEXT DEFAULT '',
            enabled INTEGER DEFAULT 1
        )
    ''')
    c.execute('''
        CREATE TABLE IF NOT EXISTS user_agreements (
            user_id INTEGER PRIMARY KEY,
            accepted BOOLEAN DEFAULT 0,
            accepted_date TEXT
        )
    ''')


    c.execute("INSERT OR IGNORE INTO bot_settings (key, value) VALUES ('force_sub_channel', '')")
    c.execute("INSERT OR IGNORE INTO bot_settings (key, value) VALUES ('force_sub_enabled', '0')")


    c.execute("SELECT value FROM bot_settings WHERE key = 'force_sub_channel'")
    old_channel = c.fetchone()
    if old_channel and old_channel[0].strip():
        channel = old_channel[0].strip()

        c.execute("SELECT 1 FROM force_sub_channels WHERE channel_url = ?", (channel,))
        if not c.fetchone():
            enabled = 1 if get_setting("force_sub_enabled") == "1" else 0
            c.execute("INSERT INTO force_sub_channels (channel_url, description, enabled) VALUES (?, ?, ?)",
                      (channel, "Ø§Ù„Ù‚Ù†Ø§Ø© Ø§Ù„Ø£Ø³Ø§Ø³ÙŠØ©", enabled))

    conn.commit()
    conn.close()

init_db()


def load_user_agreements():
    """ØªØ­Ù…ÙŠÙ„ Ù…ÙˆØ§ÙÙ‚Ø§Øª Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…ÙŠÙ† Ù…Ù† Ù‚Ø§Ø¹Ø¯Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª"""
    try:
        conn = sqlite3.connect(DB_PATH)
        c = conn.cursor()
        c.execute("SELECT user_id FROM user_agreements WHERE accepted = 1")
        rows = c.fetchall()
        for row in rows:
            USER_AGREEMENTS[row[0]] = True
        conn.close()
    except Exception as e:
        print(f"[-] Ø®Ø·Ø£ ÙÙŠ ØªØ­Ù…ÙŠÙ„ Ù…ÙˆØ§ÙÙ‚Ø§Øª Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…ÙŠÙ†: {e}")



def get_user(user_id):
    conn = sqlite3.connect(DB_PATH)
    c = conn.cursor()
    c.execute("SELECT * FROM users WHERE user_id = ?", (user_id,))
    row = c.fetchone()
    conn.close()
    return row

def save_user(user_id, username="", first_name="", last_name="", country_code=None, assigned_number=None, private_combo_country=None):
    """
    ÙŠØ­ÙØ¸ Ø£Ùˆ ÙŠØ­Ø¯Ù‘Ø« Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… Ø¨Ø§Ø³ØªØ®Ø¯Ø§Ù… Ø§Ø³ØªØ¹Ù„Ø§Ù… ÙˆØ§Ø­Ø¯ (INSERT OR REPLACE).
    Ù‡Ø°Ø§ ÙŠÙ…Ù†Ø¹ Ø£Ø®Ø·Ø§Ø¡ Ø§Ù„ØªØ²Ø§Ù…Ù† (race conditions) ÙÙŠ Ø§Ù„Ø¨ÙŠØ¦Ø§Øª Ù…ØªØ¹Ø¯Ø¯Ø© Ø§Ù„Ø®ÙŠÙˆØ·.
    """
    conn = sqlite3.connect(DB_PATH)
    c = conn.cursor()



    existing_data = get_user(user_id)
    if existing_data:

        if country_code is None:
            country_code = existing_data[4]

        if assigned_number is None:
            assigned_number = existing_data[5]

        if private_combo_country is None:
            private_combo_country = existing_data[7]

    c.execute("""
        REPLACE INTO users (user_id, username, first_name, last_name, country_code, assigned_number, is_banned, private_combo_country)
        VALUES (?, ?, ?, ?, ?, ?, COALESCE((SELECT is_banned FROM users WHERE user_id=?), 0), ?)
    """, (
        user_id,
        username,
        first_name,
        last_name,
        country_code,
        assigned_number,
        user_id,
        private_combo_country
    ))
    conn.commit()
    conn.close()


def ban_user(user_id):
    conn = sqlite3.connect(DB_PATH)
    c = conn.cursor()
    c.execute("UPDATE users SET is_banned=1 WHERE user_id=?", (user_id,))
    conn.commit()
    conn.close()

def unban_user(user_id):
    conn = sqlite3.connect(DB_PATH)
    c = conn.cursor()
    c.execute("UPDATE users SET is_banned=0 WHERE user_id=?", (user_id,))
    conn.commit()
    conn.close()



def delete_number_from_combo(number, country_code, user_id=None):
    """
    ÙŠØ­Ø°Ù Ø±Ù‚Ù… Ù…Ø¹ÙŠÙ† Ù…Ù† ÙƒÙˆÙ…Ø¨Ùˆ Ø¯ÙˆÙ„Ø© Ù…Ø¹ÙŠÙ†Ø©
    """
    try:
        conn = sqlite3.connect(DB_PATH)
        c = conn.cursor()

        if user_id:

            c.execute("SELECT numbers FROM private_combos WHERE user_id=? AND country_code=?",
                     (user_id, country_code))
        else:

            c.execute("SELECT numbers FROM combos WHERE country_code=?", (country_code,))

        row = c.fetchone()
        if not row:
            return False

        numbers_list = json.loads(row[0])


        cleaned_number = clean_number(number)
        new_numbers = []
        removed = False

        for num in numbers_list:
            if clean_number(num) != cleaned_number:
                new_numbers.append(num)
            else:
                removed = True

        if removed:

            if user_id:
                c.execute("UPDATE private_combos SET numbers=? WHERE user_id=? AND country_code=?",
                         (json.dumps(new_numbers), user_id, country_code))
            else:
                c.execute("UPDATE combos SET numbers=? WHERE country_code=?",
                         (json.dumps(new_numbers), country_code))

            conn.commit()
            print(f"[+] ØªÙ… Ø­Ø°Ù Ø§Ù„Ø±Ù‚Ù… {number} Ù…Ù† ÙƒÙˆÙ…Ø¨Ùˆ {country_code}")

        conn.close()
        return removed

    except Exception as e:
        print(f"[-] Ø®Ø·Ø£ ÙÙŠ Ø­Ø°Ù Ø§Ù„Ø±Ù‚Ù… Ù…Ù† Ø§Ù„ÙƒÙˆÙ…Ø¨Ùˆ: {e}")
        return False

def is_banned(user_id):
    user = get_user(user_id)
    return user and user[6] == 1

def get_all_users():
    conn = sqlite3.connect(DB_PATH)
    c = conn.cursor()
    c.execute("SELECT user_id FROM users WHERE is_banned=0")
    users = [row[0] for row in c.fetchall()]
    conn.close()
    return users

def get_top_otp_users(limit=10):
    """
    ØªØ±Ø¬Ø¹ Ù‚Ø§Ø¦Ù…Ø© Ø¨Ø£ÙƒØ«Ø± Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…ÙŠÙ† Ø­ØµÙˆÙ„Ø§Ù‹ Ø¹Ù„Ù‰ OTPs Ù…Ø±ØªØ¨Ø© ØªÙ†Ø§Ø²Ù„ÙŠØ§Ù‹
    """
    conn = sqlite3.connect(DB_PATH)
    c = conn.cursor()
    c.execute("""
        SELECT assigned_to, COUNT(*) as count 
        FROM otp_logs 
        WHERE assigned_to IS NOT NULL 
        GROUP BY assigned_to 
        ORDER BY count DESC 
        LIMIT ?
    """, (limit,))
    rows = c.fetchall()
    conn.close()
    
    result = []
    for user_id, count in rows:
        user = get_user_info(user_id)
        if user:
            username = user[1] or "Ø¨Ø¯ÙˆÙ† Ù…Ø¹Ø±Ù"
            first_name = user[2] or ""
            result.append((user_id, username, first_name, count))
    
    return result

def get_combo(country_code, user_id=None):
    conn = sqlite3.connect(DB_PATH)
    c = conn.cursor()
    if user_id:
        c.execute("SELECT numbers FROM private_combos WHERE user_id=? AND country_code=?", (user_id, country_code))
        row = c.fetchone()
        if row:
            conn.close()
            return json.loads(row[0])
    c.execute("SELECT numbers FROM combos WHERE country_code=?", (country_code,))
    row = c.fetchone()
    conn.close()
    return json.loads(row[0]) if row else []

def save_combo(country_code, numbers, user_id=None):
    conn = sqlite3.connect(DB_PATH)
    c = conn.cursor()
    if user_id:
        c.execute("REPLACE INTO private_combos (user_id, country_code, numbers) VALUES (?, ?, ?)",
                  (user_id, country_code, json.dumps(numbers)))
    else:
        c.execute("REPLACE INTO combos (country_code, numbers) VALUES (?, ?)",
                  (country_code, json.dumps(numbers)))
    conn.commit()
    conn.close()


def save_user_agreement(user_id):
    """Ø­ÙØ¸ Ù…ÙˆØ§ÙÙ‚Ø© Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… ÙÙŠ Ù‚Ø§Ø¹Ø¯Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª"""
    try:
        conn = sqlite3.connect(DB_PATH)
        c = conn.cursor()
        c.execute('''
            INSERT OR REPLACE INTO user_agreements (user_id, accepted, accepted_date)
            VALUES (?, 1, ?)
        ''', (user_id, datetime.now().strftime("%Y-%m-%d %H:%M:%S")))
        conn.commit()
        conn.close()
    except Exception as e:
        print(f"[-] Ø®Ø·Ø£ ÙÙŠ Ø­ÙØ¸ Ù…ÙˆØ§ÙÙ‚Ø© Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…: {e}")

def delete_combo(country_code, user_id=None):
    conn = sqlite3.connect(DB_PATH)
    c = conn.cursor()
    if user_id:
        c.execute("DELETE FROM private_combos WHERE user_id=? AND country_code=?", (user_id, country_code))
    else:
        c.execute("DELETE FROM combos WHERE country_code=?", (country_code,))
    conn.commit()
    conn.close()

def get_all_combos():
    conn = sqlite3.connect(DB_PATH)
    c = conn.cursor()
    c.execute("SELECT country_code FROM combos")
    combos = [row[0] for row in c.fetchall()]
    conn.close()
    return combos

def assign_number_to_user(user_id, number):
    conn = sqlite3.connect(DB_PATH)
    c = conn.cursor()
    c.execute("UPDATE users SET assigned_number=? WHERE user_id=?", (number, user_id))
    conn.commit()
    conn.close()

def get_user_by_number(number):
    conn = sqlite3.connect(DB_PATH)
    c = conn.cursor()
    c.execute("SELECT user_id FROM users WHERE assigned_number=?", (number,))
    row = c.fetchone()
    conn.close()
    return row[0] if row else None

def log_otp(number, otp, full_message, assigned_to=None):
    conn = sqlite3.connect(DB_PATH)
    c = conn.cursor()


    c.execute("INSERT INTO otp_logs (number, otp, full_message, timestamp, assigned_to) VALUES (?, ?, ?, ?, ?)",
              (number, otp, full_message, datetime.now().strftime("%Y-%m-%d %H:%M:%S"), assigned_to))


    cleaned_number = clean_number(number)
    country_code = None


    for code in COUNTRY_CODES:
        if cleaned_number.startswith(code):
            country_code = code
            break


    if country_code:

        delete_number_from_combo(number, country_code)


        if assigned_to:
            user = get_user(assigned_to)
            if user and user[7] == country_code:
                delete_number_from_combo(number, country_code, assigned_to)

    conn.commit()
    conn.close()

def release_number(old_number):
    if not old_number:
        return
    conn = sqlite3.connect(DB_PATH)
    c = conn.cursor()
    c.execute("UPDATE users SET assigned_number=NULL WHERE assigned_number=?", (old_number,))
    conn.commit()
    conn.close()

def get_otp_logs():
    conn = sqlite3.connect(DB_PATH)
    c = conn.cursor()
    c.execute("SELECT * FROM otp_logs")
    logs = c.fetchall()
    conn.close()
    return logs

def get_user_info(user_id):
    conn = sqlite3.connect(DB_PATH)
    c = conn.cursor()
    c.execute("SELECT * FROM users WHERE user_id=?", (user_id,))
    row = c.fetchone()
    conn.close()
    return row

def get_all_force_sub_channels(enabled_only=True):
    """Ø¬Ù„Ø¨ Ø§Ù„Ù‚Ù†ÙˆØ§Øª (Ø§Ù„Ù…ÙØ¹Ù„Ø© ÙÙ‚Ø· Ø£Ùˆ Ø¬Ù…ÙŠØ¹Ù‡Ø§)"""
    conn = sqlite3.connect(DB_PATH)
    c = conn.cursor()
    if enabled_only:
        c.execute("SELECT id, channel_url, description FROM force_sub_channels WHERE enabled = 1 ORDER BY id")
    else:
        c.execute("SELECT id, channel_url, description FROM force_sub_channels ORDER BY id")
    rows = c.fetchall()
    conn.close()
    return rows

def add_force_sub_channel(channel_url, description=""):
    """Ø¥Ø¶Ø§ÙØ© Ù‚Ù†Ø§Ø© Ø¬Ø¯ÙŠØ¯Ø© (Ù„Ø§ ØªØ³Ù…Ø­ Ø¨Ø§Ù„ØªÙƒØ±Ø§Ø±)"""
    conn = sqlite3.connect(DB_PATH)
    c = conn.cursor()
    try:
        c.execute("INSERT INTO force_sub_channels (channel_url, description, enabled) VALUES (?, ?, 1)",
                  (channel_url.strip(), description.strip()))
        conn.commit()
        return True
    except sqlite3.IntegrityError:
        return False
    finally:
        conn.close()

def delete_force_sub_channel(channel_id):
    """Ø­Ø°Ù Ù‚Ù†Ø§Ø© Ø¨Ø§Ù„Ø±Ù‚Ù… Ø§Ù„ØªØ¹Ø±ÙŠÙÙŠ"""
    conn = sqlite3.connect(DB_PATH)
    c = conn.cursor()
    c.execute("DELETE FROM force_sub_channels WHERE id = ?", (channel_id,))
    changed = c.rowcount > 0
    conn.commit()
    conn.close()
    return changed

def toggle_force_sub_channel(channel_id):
    """ØªÙØ¹ÙŠÙ„/ØªØ¹Ø·ÙŠÙ„ Ù‚Ù†Ø§Ø©"""
    conn = sqlite3.connect(DB_PATH)
    c = conn.cursor()
    c.execute("UPDATE force_sub_channels SET enabled = 1 - enabled WHERE id = ?", (channel_id,))
    conn.commit()
    conn.close()



def force_sub_check(user_id):
    """Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø§Ø´ØªØ±Ø§Ùƒ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… ÙÙŠ **Ø¬Ù…ÙŠØ¹** Ø§Ù„Ù‚Ù†ÙˆØ§Øª Ø§Ù„Ù…ÙÙØ¹ÙÙ‘Ù„Ø©"""
    channels = get_all_force_sub_channels(enabled_only=True)
    if not channels:
        return True

    for _, url, _ in channels:
        try:

            if url.startswith("https://t.me/"):
                ch = "@" + url.split("/")[-1]
            elif url.startswith("@"):
                ch = url
            else:
                continue
            member = bot.get_chat_member(ch, user_id)
            if member.status not in ["member", "administrator", "creator"]:
                return False
        except Exception as e:
            print(f"[!] Ø®Ø·Ø£ ÙÙŠ Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø§Ù„Ù‚Ù†Ø§Ø© {url}: {e}")
            return False
    return True

def force_sub_markup():
    """Ø¥Ù†Ø´Ø§Ø¡ Ø²Ø± Ù„ÙƒÙ„ Ù‚Ù†Ø§Ø© Ù…ÙÙØ¹ÙÙ‘Ù„Ø© + Ø²Ø± Ø§Ù„ØªØ­Ù‚Ù‚"""
    channels = get_all_force_sub_channels(enabled_only=True)
    if not channels:
        return None

    markup = types.InlineKeyboardMarkup()
    for _, url, desc in channels:
        text = f" {desc} âš™ï¸" if desc else "Join âš™ï¸"
        markup.add(types.InlineKeyboardButton(text, url=url))
    markup.add(types.InlineKeyboardButton("Verify â˜‘ï¸", callback_data="check_sub"))
    return markup



bot = telebot.TeleBot(BOT_TOKEN)

def get_agreement_message():
    """Ø±Ø³Ø§Ù„Ø© Ø´Ø±ÙˆØ· Ø§Ù„Ø®Ø¯Ù…Ø© Ù…Ø¹ ØªÙ†Ø³ÙŠÙ‚ HTML"""
    return """
<b>ğŸ“œ <u>Ø´Ø±ÙˆØ· Ø§Ù„Ø§Ø³ØªØ®Ø¯Ø§Ù… ÙˆØ§Ø®Ù„Ø§Ø¡ Ø§Ù„Ù…Ø³Ø¤ÙˆÙ„ÙŠØ©</u></b>

ğŸ¯ <b>Ù…Ù‚Ø¯Ù…Ø©:</b>
â€¢ Ù…Ø±Ø­Ø¨Ù‹Ø§ Ø¨Ùƒ ÙÙŠ Ø¨ÙˆØª Ø§Ø³ØªÙ‚Ø¨Ø§Ù„ Ø§Ù„Ø±Ø³Ø§Ø¦Ù„ Ø§Ù„Ù‚ØµÙŠØ±Ø©
â€¢ ÙŠØ±Ø¬Ù‰ Ù‚Ø±Ø§Ø¡Ø© Ø§Ù„Ø´Ø±ÙˆØ· Ø¨Ø¹Ù†Ø§ÙŠØ© Ù‚Ø¨Ù„ Ø§Ù„Ù…ØªØ§Ø¨Ø¹Ø©

ğŸ” <b>Ø§Ù„Ø´Ø±ÙˆØ· ÙˆØ§Ù„Ø£Ø­ÙƒØ§Ù…:</b>

<b>1. ğŸ“ Ø§Ù„ØºØ±Ø¶ Ù…Ù† Ø§Ù„Ø¨ÙˆØª:</b>
   â€¢ Ù‡Ø°Ø§ Ø§Ù„Ø¨ÙˆØª Ù…Ø®ØµØµ <b>Ù„Ù„Ø£ØºØ±Ø§Ø¶ Ø§Ù„ØªØ¹Ù„ÙŠÙ…ÙŠØ© ÙˆØ§Ù„Ø§Ø®ØªØ¨Ø§Ø±ÙŠØ© ÙÙ‚Ø·</b>
   â€¢ ÙŠØ¬Ø¨ Ø§Ø³ØªØ®Ø¯Ø§Ù…Ù‡ Ø¶Ù…Ù† <b>Ø§Ù„Ø£Ø·Ø± Ø§Ù„Ù‚Ø§Ù†ÙˆÙ†ÙŠØ© ÙˆØ§Ù„Ø£Ø®Ù„Ø§Ù‚ÙŠØ©</b>

<b>2. âš–ï¸ Ø§Ø®Ù„Ø§Ø¡ Ø§Ù„Ù…Ø³Ø¤ÙˆÙ„ÙŠØ©:</b>
   â€¢ Ø§Ù„Ù…Ø·ÙˆØ± <b>ØºÙŠØ± Ù…Ø³Ø¤ÙˆÙ„</b> Ø¹Ù† Ø£ÙŠ Ø§Ø³ØªØ®Ø¯Ø§Ù… ØºÙŠØ± Ù‚Ø§Ù†ÙˆÙ†ÙŠ Ù„Ù„Ø¨ÙˆØª
   â€¢ Ø£Ù†Øª <b>Ø§Ù„Ù…Ø³Ø¤ÙˆÙ„ Ø§Ù„ÙˆØ­ÙŠØ¯</b> Ø¹Ù† Ø§Ø³ØªØ®Ø¯Ø§Ù…Ùƒ Ù„Ù„Ø¨ÙˆØª ÙˆØ§Ù„Ù†ØªØ§Ø¦Ø¬ Ø§Ù„Ù…ØªØ±ØªØ¨Ø© Ø¹Ù„ÙŠÙ‡

<b>3. ğŸ“ Ø§Ù„Ø£Ø±Ù‚Ø§Ù… ÙˆØ§Ù„Ø¨ÙŠØ§Ù†Ø§Øª:</b>
   â€¢ Ø§Ù„Ø£Ø±Ù‚Ø§Ù… Ø§Ù„Ù…ØªÙˆÙØ±Ø© Ù‡ÙŠ <b>Ù„Ø£ØºØ±Ø§Ø¶ Ø§Ù„Ø§Ø®ØªØ¨Ø§Ø± ÙˆØ§Ù„ØªØ¬Ø±Ø¨Ø© ÙÙ‚Ø·</b>
   â€¢ ÙŠÙØ­Ø¸Ø± Ø§Ø³ØªØ®Ø¯Ø§Ù… Ø§Ù„Ø£Ø±Ù‚Ø§Ù… Ù„Ø£ÙŠ Ù†Ø´Ø§Ø· Ø§Ø­ØªÙŠØ§Ù„ÙŠ Ø£Ùˆ ØºÙŠØ± Ù‚Ø§Ù†ÙˆÙ†ÙŠ

<b>4. ğŸ”’ Ø§Ù„Ø®ØµÙˆØµÙŠØ©:</b>
   â€¢ Ù†Ø­Ù† Ù†Ø­ØªØ±Ù… Ø®ØµÙˆØµÙŠØªÙƒ <b>ÙˆÙ„Ø§ Ù†Ø®Ø²Ù† Ø¨ÙŠØ§Ù†Ø§ØªÙƒ Ø§Ù„Ø´Ø®ØµÙŠØ©</b>
   â€¢ ÙŠØªÙ… Ø­Ø°Ù Ø§Ù„Ø±Ø³Ø§Ø¦Ù„ ÙˆØ§Ù„Ø±Ù…ÙˆØ² Ø¨Ø¹Ø¯ Ø¥Ø±Ø³Ø§Ù„Ù‡Ø§

<b>5. ğŸ“‹ Ø§Ù„ØªØ²Ø§Ù… Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…:</b>
   â€¢ Ø¨Ø§Ø³ØªØ®Ø¯Ø§Ù…Ùƒ Ù„Ù„Ø¨ÙˆØªØŒ ØªØ¤ÙƒØ¯ Ø£Ù†Ùƒ:
     âœ“ ØªØ¨Ù„Øº Ù…Ù† Ø§Ù„Ø¹Ù…Ø± 18 Ø³Ù†Ø© Ø£Ùˆ Ø£ÙƒØ«Ø±
     âœ“ Ù„Ù† ØªØ³ØªØ®Ø¯Ù… Ø§Ù„Ø¨ÙˆØª Ù„Ø£ØºØ±Ø§Ø¶ ØºÙŠØ± Ù‚Ø§Ù†ÙˆÙ†ÙŠØ©
     âœ“ ØªØªØ­Ù…Ù„ Ø§Ù„Ù…Ø³Ø¤ÙˆÙ„ÙŠØ© Ø§Ù„ÙƒØ§Ù…Ù„Ø© Ø¹Ù† Ø£ÙØ¹Ø§Ù„Ùƒ

<b>âš ï¸ ØªØ­Ø°ÙŠØ± Ù‡Ø§Ù…:</b>
   â€¢ Ø£ÙŠ Ø§Ù†ØªÙ‡Ø§Ùƒ Ù„Ù„Ù‚ÙˆØ§Ù†ÙŠÙ† Ø§Ù„Ù…Ø­Ù„ÙŠØ© Ø£Ùˆ Ø§Ù„Ø¯ÙˆÙ„ÙŠØ© Ù‡Ùˆ <b>Ù…Ø³Ø¤ÙˆÙ„ÙŠØªÙƒ Ø§Ù„Ø´Ø®ØµÙŠØ©</b>
   â€¢ ÙŠØ­Ù‚ Ù„Ù„Ù…Ø·ÙˆØ± <b>Ø­Ø¸Ø± Ø£ÙŠ Ù…Ø³ØªØ®Ø¯Ù…</b> ÙŠØ®Ø§Ù„Ù Ø§Ù„Ø´Ø±ÙˆØ· Ø¯ÙˆÙ† Ø³Ø§Ø¨Ù‚ Ø¥Ù†Ø°Ø§Ø±

<b>âœ… Ø¨Ø§Ù„Ø¶ØºØ· Ø¹Ù„Ù‰ "Ø£ÙˆØ§ÙÙ‚ Ø¹Ù„Ù‰ Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø´Ø±ÙˆØ·"ØŒ ÙØ¥Ù†Ùƒ:</b>
   â€¢ ØªÙ‚Ø± Ø¨Ø£Ù†Ùƒ Ù‚Ø±Ø£Øª ÙˆÙÙ‡Ù…Øª Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø´Ø±ÙˆØ·
   â€¢ ØªÙˆØ§ÙÙ‚ Ø¹Ù„Ù‰ Ø§Ù„Ø§Ù„ØªØ²Ø§Ù… Ø¨Ù‡Ø§
   â€¢ ØªØªØ­Ù…Ù„ Ø§Ù„Ù…Ø³Ø¤ÙˆÙ„ÙŠØ© Ø§Ù„ÙƒØ§Ù…Ù„Ø© Ø¹Ù† Ø§Ø³ØªØ®Ø¯Ø§Ù…Ùƒ Ù„Ù„Ø¨ÙˆØª

<code>â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”</code>
<i>ğŸ“… ØªÙ… Ø§Ù„ØªØ­Ø¯ÙŠØ«: ÙŠÙ†Ø§ÙŠØ± 2024</i>
"""

def get_agreement_markup():
    """Ø¥Ù†Ø´Ø§Ø¡ ÙˆØ§Ø¬Ù‡Ø© Ø§Ù„Ù…ÙˆØ§ÙÙ‚Ø© Ø¹Ù„Ù‰ Ø§Ù„Ø´Ø±ÙˆØ·"""
    markup = types.InlineKeyboardMarkup(row_width=1)
    markup.add(
        types.InlineKeyboardButton("âœ… Ø£ÙˆØ§ÙÙ‚ Ø¹Ù„Ù‰ Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø´Ø±ÙˆØ·", callback_data="accept_terms"),
        types.InlineKeyboardButton("ğŸ“„ Ù‚Ø±Ø§Ø¡Ø© Ø§Ù„Ù…Ø²ÙŠØ¯", url="https://t.me/otp_bemer")
    )
    return markup
    
def is_admin(user_id):
    return user_id in ADMIN_IDS

@bot.message_handler(commands=['start'])
def send_welcome(message):
    user_id = message.from_user.id
    
    # Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø§Ù„Ø­Ø¸Ø±
    if is_banned(user_id):
        bot.reply_to(message, "ğŸš« You are banned.")
        return
    
    # Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ù…ÙˆØ§ÙÙ‚Ø© Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… Ø¹Ù„Ù‰ Ø§Ù„Ø´Ø±ÙˆØ·
    if user_id not in USER_AGREEMENTS or not USER_AGREEMENTS[user_id]:
        # Ø¥Ø±Ø³Ø§Ù„ Ø±Ø³Ø§Ù„Ø© Ø§Ù„Ø´Ø±ÙˆØ·
        bot.send_message(
            message.chat.id,
            get_agreement_message(),
            parse_mode="HTML",
            reply_markup=get_agreement_markup()
        )
        return
    
    # Ø¥Ø°Ø§ ÙˆØ§ÙÙ‚ Ø¹Ù„Ù‰ Ø§Ù„Ø´Ø±ÙˆØ·ØŒ ØªØ­Ù‚Ù‚ Ù…Ù† Ø§Ù„Ø§Ø´ØªØ±Ø§Ùƒ Ø§Ù„Ø¥Ø¬Ø¨Ø§Ø±ÙŠ
    if not force_sub_check(user_id):
        markup = force_sub_markup()
        if markup:
            bot.send_message(message.chat.id, 
                "ğŸš« <b>ÙŠØ¬Ø¨ Ø§Ù„Ø§Ø´ØªØ±Ø§Ùƒ ÙÙŠ Ø§Ù„Ù‚Ù†ÙˆØ§Øª Ø§Ù„ØªØ§Ù„ÙŠØ© Ø£ÙˆÙ„Ø§Ù‹:</b>",
                parse_mode="HTML",
                reply_markup=markup
            )
        else:
            bot.send_message(message.chat.id, "ğŸ”’ Ø§Ù„Ø§Ø´ØªØ±Ø§Ùƒ Ø§Ù„Ø¥Ø¬Ø¨Ø§Ø±ÙŠ Ù…ÙØ¹Ù„ Ù„ÙƒÙ† Ù„Ù… ÙŠØªÙ… ØªØ­Ø¯ÙŠØ¯ Ù‚Ù†Ø§Ø©!")
        return
    
    # Ø§Ù„Ø¨Ø§Ù‚ÙŠ ÙƒÙ…Ø§ Ù‡Ùˆ Ù…Ø¹ ØªØ¹Ø¯ÙŠÙ„ Ø¨Ø³ÙŠØ· ÙÙŠ Ø§Ù„Ø¹Ø±Ø¶:
    if not get_user(user_id):
        for admin in ADMIN_IDS:
            try:
                caption = f"ğŸ†• Ù…Ø³ØªØ®Ø¯Ù… Ø¬Ø¯ÙŠØ¯ Ø¯Ø®Ù„ Ø§Ù„Ø¨ÙˆØª:\nğŸ†”: `{message.from_user.id}`\nğŸ‘¤: @{message.from_user.username or 'None'}\nØ§Ù„Ø§Ø³Ù…: {message.from_user.first_name or ''} {message.from_user.last_name or ''}"
                if message.from_user.photo:
                    photo = bot.get_user_profile_photos(message.from_user.id).photos
                    if photo:
                        bot.send_photo(admin, photo[0][-1].file_id, caption=caption, parse_mode="Markdown")
                    else:
                        bot.send_message(admin, caption, parse_mode="Markdown")
                else:
                    bot.send_message(admin, caption, parse_mode="Markdown")
            except:
                pass
    save_user(
        user_id,
        username=message.from_user.username or "",
        first_name=message.from_user.first_name or "",
        last_name=message.from_user.last_name or ""
    )

    markup = types.InlineKeyboardMarkup()
    user = get_user(user_id)
    private_combo = user[7] if user else None
    all_combos = get_all_combos()

    if is_admin(user_id):
        markup.add(types.InlineKeyboardButton("ğŸ” ğ€ğƒğŒğˆğ ğğ€ğğ„ğ‹ğ–¤›", callback_data="admin_panel"))

    if private_combo and private_combo in COUNTRY_CODES:
        name, flag, _ = COUNTRY_CODES[private_combo]
        markup.add(types.InlineKeyboardButton(f"{flag} {name} (Private)", callback_data=f"country_{private_combo}"))

    for code in all_combos:
        if code in COUNTRY_CODES and code != private_combo:
            name, flag, _ = COUNTRY_CODES[code]
            markup.add(types.InlineKeyboardButton(f"{flag} {name}", callback_data=f"country_{code}"))

    row_buttons = [
        types.InlineKeyboardButton("ğ¨ğ­ğ©", url="https://t.me/otp_bemer")
    ]
    bot.send_message(message.chat.id, "ğŸŒ ğ‘ºğ‘¬ğ‘³ğ‘¬ğ‘ªğ‘» ğ’€ğ‘¶ğ‘¼ğ‘¹ ğ‘ªğ‘¶ğ‘¼ğ‘µğ‘»ğ‘¹ğ’€ğ–¥µ:", reply_markup=markup)

@bot.callback_query_handler(func=lambda call: call.data == "check_sub")
def check_subscription(call):
    if force_sub_check(call.from_user.id):
        bot.answer_callback_query(call.id, "âœ… ØªÙ… Ø§Ù„ØªØ­Ù‚Ù‚! ÙŠÙ…ÙƒÙ†Ùƒ Ø§Ø³ØªØ®Ø¯Ø§Ù… Ø§Ù„Ø¨ÙˆØª Ø§Ù„Ø¢Ù†.", show_alert=True)
        send_welcome(call.message)
    else:
        bot.answer_callback_query(call.id, "âŒ Ù„Ù… ØªØ´ØªØ±Ùƒ Ø¨Ø¹Ø¯!", show_alert=True)

@bot.callback_query_handler(func=lambda call: call.data.startswith("country_"))
def handle_country_selection(call):
    if is_banned(call.from_user.id):
        bot.answer_callback_query(call.id, "ğŸš« You are banned.", show_alert=True)
        return
    if not force_sub_check(call.from_user.id):
        markup = force_sub_markup()
        if markup:
            bot.send_message(call.message.chat.id, "ğŸš¦ Access Locked. Join then Verify.", reply_markup=markup)
        else:
            bot.send_message(call.message.chat.id, "ğŸ”’ Ø§Ù„Ø§Ø´ØªØ±Ø§Ùƒ Ø§Ù„Ø¥Ø¬Ø¨Ø§Ø±ÙŠ Ù…ÙØ¹Ù„ Ù„ÙƒÙ† Ù„Ù… ÙŠØªÙ… ØªØ­Ø¯ÙŠØ¯ Ù‚Ù†Ø§Ø©!")
        return
    country_code = call.data.split("_", 1)[1]
    available_numbers = get_available_numbers(country_code, call.from_user.id)
    if not available_numbers:
        bot.edit_message_text("âŒ Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø£Ø±Ù‚Ø§Ù… Ù‚ÙŠØ¯ Ø§Ù„Ø§Ø³ØªØ®Ø¯Ø§Ù… Ø­Ø§Ù„ÙŠÙ‹Ø§.", call.message.chat.id, call.message.message_id)
        return
    assigned = random.choice(available_numbers)
    old_user = get_user(call.from_user.id)
    if old_user and old_user[5]:
        release_number(old_user[5])
    assign_number_to_user(call.from_user.id, assigned)
    save_user(call.from_user.id, country_code=country_code, assigned_number=assigned)
    name, flag, _ = COUNTRY_CODES.get(country_code, ("Unknown", "ğŸŒ", ""))
    msg_text = f"ğŸ“*Your Number From {flag} {name}* : `{assigned}`\n\n *Waiting for OTP.â€¦ğŸ”‘*\n\n_ğŸš¨ The OTP will be sent to you here_"
    markup = types.InlineKeyboardMarkup()

    markup.add(types.InlineKeyboardButton("ğŸ”„ Change Number", callback_data=f"change_num_{country_code}"))
    markup.add(types.InlineKeyboardButton("ğŸŒ Change Country", callback_data="back_to_countries"))

    markup.add(types.InlineKeyboardButton("ğ¨ğ­ğ©", url="https://t.me/otp_bemer"))

    bot.edit_message_text(msg_text, call.message.chat.id, call.message.message_id, reply_markup=markup, parse_mode="Markdown")

@bot.callback_query_handler(func=lambda call: call.data.startswith("change_num_"))
def change_number(call):
    if is_banned(call.from_user.id):
        return
    if not force_sub_check(call.from_user.id):
        return
    country_code = call.data.split("_", 2)[2]
    available_numbers = get_available_numbers(country_code, call.from_user.id)
    if not available_numbers:
        bot.answer_callback_query(call.id, "âŒ ğ ğ¦ğ¢ğš ğ€ğ¥ğšğ«ğ¤ğšğ¦ ğ¤ğ¢ğ ğ€ğ¥ğšğ¬ğ­ğ¤ğ¡ğğšğ¦.", show_alert=True)
        return
    old_user = get_user(call.from_user.id)
    if old_user and old_user[5]:
        release_number(old_user[5])
    assigned = random.choice(available_numbers)
    assign_number_to_user(call.from_user.id, assigned)
    save_user(call.from_user.id, assigned_number=assigned)
    name, flag, _ = COUNTRY_CODES.get(country_code, ("ğ”ğ§ğ¤ğ§ğ¨ğ°ğ§", "ğŸŒ", ""))
    msg_text = f"ğŸ“*ğ˜ğ¨ğ®ğ« ğğ®ğ¦ğ›ğğ« ğ…ğ«ğ¨ğ¦ {flag} {name}* : `{assigned}`\n\n *ğ–ğšğ¢ğ­ğ¢ğ§ğ  ğŸğ¨ğ« ğğ“ğ.â€¦ğŸ”‘*\n\n_ğŸš¨ ğ“ğ¡ğ ğğ“ğ ğ°ğ¢ğ¥ğ¥ ğ›ğ ğ¬ğğ§ğ­ ğ­ğ¨ ğ²ğ¨ğ® ğ¡ğğ«ğ_"
    markup = types.InlineKeyboardMarkup()
    markup.add(types.InlineKeyboardButton("ğŸ”„ ğ‚ğ¡ğšğ§ğ ğ ğğ®ğ¦ğ›ğğ«", callback_data=f"change_num_{country_code}"))
    markup.add(types.InlineKeyboardButton("ğŸŒ ğ‚ğ¡ğšğ§ğ ğ ğ‚ğ¨ğ®ğ§ğ­ğ«ğ²", callback_data="back_to_countries"))
    markup.add(types.InlineKeyboardButton("ğ¨ğ­ğ©", url="https://t.me/otp_bemer"))
    bot.edit_message_text(msg_text, call.message.chat.id, call.message.message_id, reply_markup=markup, parse_mode="Markdown")

@bot.callback_query_handler(func=lambda call: call.data == "back_to_countries")
def back_to_countries(call):

    markup = types.InlineKeyboardMarkup()
    user = get_user(call.from_user.id)
    private_combo = user[7] if user else None
    all_combos = get_all_combos()


    if private_combo and private_combo in COUNTRY_CODES:
        name, flag, _ = COUNTRY_CODES[private_combo]
        markup.add(types.InlineKeyboardButton(f"{flag} {name} (Private)", callback_data=f"country_{private_combo}"))


    for code in all_combos:
        if code in COUNTRY_CODES and code != private_combo:
            name, flag, _ = COUNTRY_CODES[code]
            markup.add(types.InlineKeyboardButton(f"{flag} {name}", callback_data=f"country_{code}"))


    if is_admin(call.from_user.id):
        markup.add(types.InlineKeyboardButton("ğŸ” ğ€ğƒğŒğˆğ ğğ€ğğ„ğ‹ğ–¤›", callback_data="admin_panel"))


    try:
        bot.edit_message_text(
            chat_id=call.message.chat.id,
            message_id=call.message.message_id,
            text="ğŸŒ Select your country:",
            reply_markup=markup
        )
    except Exception as e:
        print(f"Error editing message: {e}")
        bot.answer_callback_query(call.id)





user_states = {}

# ÙÙŠ Ø¯Ø§Ù„Ø© admin_main_menu() Ø£Ø¶Ù Ù‡Ø°Ø§ Ø§Ù„Ø²Ø±:
def admin_main_menu():
    markup = types.InlineKeyboardMarkup()
    btns = [
        types.InlineKeyboardButton("â• ğ€ğğ ğ‚ğ¨ğ¦ğ›ğ¨", callback_data="admin_add_combo"),
        types.InlineKeyboardButton("ğŸ—‘ï¸ ğƒğğ¥ğğ­ğ ğ‚ğ¨ğ¦ğ›ğ¨", callback_data="admin_del_combo"),
        types.InlineKeyboardButton("ğŸ“Š ğ’ğ­ğšğ­ğ¬", callback_data="admin_stats"),
        types.InlineKeyboardButton("ğŸ“ˆ ğ…ğ®ğ¥ğ¥ ğ‘ğğ©ğ¨ğ«ğ­", callback_data="admin_full_report"),
        types.InlineKeyboardButton("ğŸš« ğğšğ§ ğ”ğ¬ğğ«", callback_data="admin_ban"),
        types.InlineKeyboardButton("âœ… ğ”ğ§ğ›ğšğ§ ğ”ğ¬ğğ«", callback_data="admin_unban"),
        types.InlineKeyboardButton("ğŸ“¢ ğğ«ğ¨ğšğğœğšğ¬ğ­ ğ€ğ¥ğ¥", callback_data="admin_broadcast_all"),
        types.InlineKeyboardButton("ğŸ“¤ ğğ«ğ¨ğšğğœğšğ¬ğ­ ğ”ğ¬ğğ«", callback_data="admin_broadcast_user"),
        types.InlineKeyboardButton("ğŸ‘¤ ğ”ğ¬ğğ« ğˆğ§ğŸğ¨", callback_data="admin_user_info"),
        types.InlineKeyboardButton("ğŸ”” ğ€ğ¬ğ¡ğ­ğ«ğšğ¤ ğ„ğ£ğ›ğšğ«ğ¢", callback_data="admin_force_sub"),
        types.InlineKeyboardButton("ğ‘…ğ¸ğ¹ğ‘…ğ¸ğ‘†ğ» ğ¶ğ‘‚ğ‘€ğµğ‘‚ğ–¥¢", callback_data="admin_refresh_combo"),
        types.InlineKeyboardButton("ğŸ“‹ ğ‹ğ°ğšğ¡ğšğ­ ğ€ğ¥ğšğ«ğ¤ğšğ¦", callback_data="admin_dashboards"),
        types.InlineKeyboardButton("ğŸ” ğŠğ¨ğ¦ğ›ğ¨ ğğ«ğšğ¢ğ¯ğšğ­", callback_data="admin_private_combo"),
        types.InlineKeyboardButton("ğŸ† ğ“ğ¨ğ© ğ”ğ¬ğğ«ğ¬", callback_data="admin_top_users"),  # <-- Ø£Ø¶Ù Ù‡Ø°Ø§ Ø§Ù„Ø³Ø·Ø±
    ]
    for i in range(0, len(btns), 2):
        markup.row(*btns[i:i+2])
    return markup

@bot.callback_query_handler(func=lambda call: call.data == "admin_panel")
def admin_panel(call):
    if not is_admin(call.from_user.id):
        return
    bot.edit_message_text("ğŸ” ğ€ğğ¦ğ¢ğ§ ğğšğ§ğğ¥", call.message.chat.id, call.message.message_id, reply_markup=admin_main_menu())




@bot.callback_query_handler(func=lambda call: call.data == "admin_force_sub")
def admin_force_sub(call):
    if not is_admin(call.from_user.id):
        return

    channels = get_all_force_sub_channels(enabled_only=False)
    text = "âš™ï¸ ğŒğšğ§ğšğ ğ ğ…ğ¨ğ«ğœğ ğ’ğ®ğ›ğ¬ğœğ«ğ¢ğ©ğ­ğ¢ğ¨ğ§ ğ‚ğ¡ğšğ§ğ§ğğ¥ğ¬:\n"
    text += f"ğ“ğ¨ğ­ğšğ¥ ğ‚ğ¡ğšğ§ğ§ğğ¥ğ¬: {len(channels)}\n"
    text += "â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n"

    markup = types.InlineKeyboardMarkup()
    for ch_id, url, desc in channels:
        conn = sqlite3.connect(DB_PATH)
        c = conn.cursor()
        c.execute("SELECT enabled FROM force_sub_channels WHERE id=?", (ch_id,))
        enabled = c.fetchone()[0]
        conn.close()
        status = "âœ…" if enabled else "âŒ"
        btn_text = f"{status} {desc or url[:25]}"
        markup.add(types.InlineKeyboardButton(btn_text, callback_data=f"edit_force_ch_{ch_id}"))

    markup.add(types.InlineKeyboardButton("â• ğ€ğğ ğ‚ğ¡ğšğ§ğ§ğğ¥", callback_data="add_force_ch"))
    markup.add(types.InlineKeyboardButton("âŸµã€ ğŸŒ€ ğ™±ğ™°ğ™²ğ™º ğŸŒ€ ã€âŸ¶", callback_data="admin_panel"))
    bot.edit_message_text(text, call.message.chat.id, call.message.message_id, reply_markup=markup)


@bot.callback_query_handler(func=lambda call: call.data == "add_force_ch")
def add_force_ch_step1(call):
    if not is_admin(call.from_user.id):
        return
    user_states[call.from_user.id] = "add_force_ch_url"
    markup = types.InlineKeyboardMarkup()
    markup.add(types.InlineKeyboardButton("âŸµã€ ğŸŒ€ ğ™±ğ™°ğ™²ğ™º ğŸŒ€ ã€âŸ¶", callback_data="admin_force_sub"))
    bot.edit_message_text("ğ’ğğ§ğ ğœğ¡ğšğ§ğ§ğğ¥ ğ¥ğ¢ğ§ğ¤ (ğ.ğ .: https://t.me/xxx ğ¨ğ« @xxx):", call.message.chat.id, call.message.message_id, reply_markup=markup)

@bot.message_handler(func=lambda msg: user_states.get(msg.from_user.id) == "add_force_ch_url")
def add_force_ch_step2(message):
    url = message.text.strip()
    if not (url.startswith("@") or url.startswith("https://t.me/")):
        bot.reply_to(message, "âŒ ğˆğ§ğ¯ğšğ¥ğ¢ğ ğ¥ğ¢ğ§ğ¤! ğŒğ®ğ¬ğ­ ğ¬ğ­ğšğ«ğ­ ğ°ğ¢ğ­ğ¡ @ ğ¨ğ« https://t.me/")
        return
    user_states[message.from_user.id] = {"step": "add_force_ch_desc", "url": url}
    bot.reply_to(message, "ğ„ğ§ğ­ğğ« ğœğ¡ğšğ§ğ§ğğ¥ ğğğ¬ğœğ«ğ¢ğ©ğ­ğ¢ğ¨ğ§ (ğ¨ğ« ğ¥ğğšğ¯ğ ğ›ğ¥ğšğ§ğ¤):")

@bot.message_handler(func=lambda msg: isinstance(user_states.get(msg.from_user.id), dict) and user_states[msg.from_user.id].get("step") == "add_force_ch_desc")
def add_force_ch_step3(message):
    data = user_states[message.from_user.id]
    url = data["url"]
    desc = message.text.strip()
    if add_force_sub_channel(url, desc):
        bot.reply_to(message, f"âœ… ğ‚ğ¡ğšğ§ğ§ğğ¥ ğšğğğğ:\n{url}\nğƒğğ¬ğœ: {desc or 'â€”'}")
    else:
        bot.reply_to(message, "âŒ ğ‚ğ¡ğšğ§ğ§ğğ¥ ğšğ¥ğ«ğğšğğ² ğğ±ğ¢ğ¬ğ­ğ¬!")
    del user_states[message.from_user.id]


@bot.callback_query_handler(func=lambda call: call.data.startswith("edit_force_ch_"))
def edit_force_ch(call):
    if not is_admin(call.from_user.id):
        return
    try:
        ch_id = int(call.data.split("_", 3)[3])
    except:
        return
    conn = sqlite3.connect(DB_PATH)
    c = conn.cursor()
    c.execute("SELECT channel_url, description, enabled FROM force_sub_channels WHERE id=?", (ch_id,))
    row = c.fetchone()
    conn.close()
    if not row:
        bot.answer_callback_query(call.id, "âŒ ğ‚ğ¡ğšğ§ğ§ğğ¥ ğ§ğ¨ğ­ ğŸğ¨ğ®ğ§ğ!", show_alert=True)
        return

    url, desc, enabled = row
    status = "ğ„ğ§ğšğ›ğ¥ğğ" if enabled else "ğƒğ¢ğ¬ğšğ›ğ¥ğğ"
    text = f"ğŸ”§ ğŒğšğ§ğšğ ğ ğ‚ğ¡ğšğ§ğ§ğğ¥:\nğ‹ğ¢ğ§ğ¤: {url}\nğƒğğ¬ğœ: {desc or 'â€”'}\nğ’ğ­ğšğ­ğ®ğ¬: {status}"
    markup = types.InlineKeyboardMarkup()
    markup.add(types.InlineKeyboardButton("âœï¸ ğ„ğğ¢ğ­ ğƒğğ¬ğœ", callback_data=f"edit_desc_{ch_id}"))
    if enabled:
        markup.add(types.InlineKeyboardButton("âŒ ğƒğ¢ğ¬ğšğ›ğ¥ğ", callback_data=f"toggle_ch_{ch_id}"))
    else:
        markup.add(types.InlineKeyboardButton("âœ… ğ„ğ§ğšğ›ğ¥ğ", callback_data=f"toggle_ch_{ch_id}"))
    markup.add(types.InlineKeyboardButton("ğŸ—‘ï¸ ğƒğğ¥ğğ­ğ", callback_data=f"del_ch_{ch_id}"))
    markup.add(types.InlineKeyboardButton("âŸµã€ ğŸŒ€ ğ™±ğ™°ğ™²ğ™º ğŸŒ€ ã€âŸ¶", callback_data="admin_force_sub"))
    bot.edit_message_text(text, call.message.chat.id, call.message.message_id, reply_markup=markup)


@bot.callback_query_handler(func=lambda call: call.data.startswith("toggle_ch_"))
def toggle_ch(call):
    ch_id = int(call.data.split("_", 2)[2])
    toggle_force_sub_channel(ch_id)
    bot.answer_callback_query(call.id, "ğŸ”„ ğ‚ğ¡ğšğ§ğ§ğğ¥ ğ¬ğ­ğšğ­ğ®ğ¬ ğœğ¡ğšğ§ğ ğğ", show_alert=True)
    admin_force_sub(call)

@bot.callback_query_handler(func=lambda call: call.data.startswith("del_ch_"))
def del_ch(call):
    ch_id = int(call.data.split("_", 2)[2])
    if delete_force_sub_channel(ch_id):
        bot.answer_callback_query(call.id, "âœ… ğƒğğ¥ğğ­ğğ!", show_alert=True)
    else:
        bot.answer_callback_query(call.id, "âŒ ğ…ğšğ¢ğ¥ğğ ğ­ğ¨ ğğğ¥ğğ­ğ!", show_alert=True)
    admin_force_sub(call)


@bot.callback_query_handler(func=lambda call: call.data.startswith("edit_desc_"))
def edit_desc_step1(call):
    ch_id = int(call.data.split("_", 2)[2])
    user_states[call.from_user.id] = f"edit_desc_{ch_id}"
    markup = types.InlineKeyboardMarkup()
    markup.add(types.InlineKeyboardButton("âŸµã€ ğŸŒ€ ğ™±ğ™°ğ™²ğ™º ğŸŒ€ ã€âŸ¶", callback_data=f"edit_force_ch_{ch_id}"))
    bot.edit_message_text("ğ„ğ§ğ­ğğ« ğ§ğğ° ğğğ¬ğœğ«ğ¢ğ©ğ­ğ¢ğ¨ğ§:", call.message.chat.id, call.message.message_id, reply_markup=markup)

@bot.message_handler(func=lambda msg: isinstance(user_states.get(msg.from_user.id), str) and user_states[msg.from_user.id].startswith("edit_desc_"))
def edit_desc_step2(message):
    try:
        ch_id = int(user_states[message.from_user.id].split("_")[2])
        desc = message.text.strip()
        conn = sqlite3.connect(DB_PATH)
        c = conn.cursor()
        c.execute("UPDATE force_sub_channels SET description = ? WHERE id = ?", (desc, ch_id))
        conn.commit()
        conn.close()
        bot.reply_to(message, "âœ… ğƒğğ¬ğœğ«ğ¢ğ©ğ­ğ¢ğ¨ğ§ ğ®ğ©ğğšğ­ğğ!")
    except Exception as e:
        bot.reply_to(message, f"âŒ ğ„ğ«ğ«ğ¨ğ«: {e}")
    del user_states[message.from_user.id]

@bot.callback_query_handler(func=lambda call: call.data == "admin_add_combo")
def admin_add_combo(call):
    if not is_admin(call.from_user.id):
        return
    user_states[call.from_user.id] = "waiting_combo_file"
    markup = types.InlineKeyboardMarkup()
    markup.add(types.InlineKeyboardButton("âŸµã€ ğŸŒ€ ğ™±ğ™°ğ™²ğ™º ğŸŒ€ ã€âŸ¶", callback_data="admin_panel"))
    bot.edit_message_text("ğŸ“¤ ğ’ğğ§ğ ğ‚ğ¨ğ¦ğ›ğ¨ ğŸğ¢ğ¥ğ ğ¢ğ§ ğ“ğ—ğ“ ğŸğ¨ğ«ğ¦ğšğ­", call.message.chat.id, call.message.message_id, reply_markup=markup)

@bot.message_handler(content_types=['document'])
def handle_combo_file(message):
    if not is_admin(message.from_user.id):
        return
    if user_states.get(message.from_user.id) != "waiting_combo_file":
        return
    try:
        file_info = bot.get_file(message.document.file_id)
        downloaded_file = bot.download_file(file_info.file_path)
        content = downloaded_file.decode('utf-8')
        lines = [line.strip() for line in content.splitlines() if line.strip()]
        if not lines:
            bot.reply_to(message, "âŒ ğ…ğ¢ğ¥ğ ğ¢ğ¬ ğğ¦ğ©ğ­ğ²!")
            return
        first_num = clean_number(lines[0])
        country_code = None
        for code in COUNTRY_CODES:
            if first_num.startswith(code):
                country_code = code
                break
        if not country_code:
            bot.reply_to(message, "âŒ ğ‚ğ¨ğ®ğ§ğ­ğ«ğ² ğœğ¨ğ®ğ¥ğ ğ§ğ¨ğ­ ğ›ğ ğğğ­ğğ«ğ¦ğ¢ğ§ğğ!")
            return
        save_combo(country_code, lines)
        name, flag, _ = COUNTRY_CODES[country_code]
        bot.reply_to(message, f"âœ… ğ‚ğ¨ğ¦ğ›ğ¨ ğ¬ğšğ¯ğğ ğŸğ¨ğ« {flag} {name}\nğŸ”¢ ğğ®ğ¦ğ›ğğ«ğ¬ ğœğ¨ğ®ğ§ğ­: {len(lines)}")
        del user_states[message.from_user.id]
    except Exception as e:
        bot.reply_to(message, f"âŒ ğ„ğ«ğ«ğ¨ğ«: {e}")

@bot.callback_query_handler(func=lambda call: call.data == "admin_del_combo")
def admin_del_combo(call):
    if not is_admin(call.from_user.id):
        return
    combos = get_all_combos()
    if not combos:
        bot.answer_callback_query(call.id, "ğğ¨ ğœğ¨ğ¦ğ›ğ¨ğ¬ ğŸğ¨ğ®ğ§ğ!")
        return
    markup = types.InlineKeyboardMarkup()
    for code in combos:
        if code in COUNTRY_CODES:
            name, flag, _ = COUNTRY_CODES[code]
            markup.add(types.InlineKeyboardButton(f"{flag} {name}", callback_data=f"del_combo_{code}"))
    markup.add(types.InlineKeyboardButton("âŸµã€ ğŸŒ€ ğ™±ğ™°ğ™²ğ™º ğŸŒ€ ã€âŸ¶", callback_data="admin_panel"))
    bot.edit_message_text("ğ’ğğ¥ğğœğ­ ğœğ¨ğ¦ğ›ğ¨ ğ­ğ¨ ğğğ¥ğğ­ğ:", call.message.chat.id, call.message.message_id, reply_markup=markup)

@bot.callback_query_handler(func=lambda call: call.data.startswith("del_combo_"))
def confirm_del_combo(call):
    if not is_admin(call.from_user.id):
        return
    code = call.data.split("_", 2)[2]
    delete_combo(code)
    name, flag, _ = COUNTRY_CODES.get(code, ("Unknown", "ğŸŒ", ""))
    markup = types.InlineKeyboardMarkup()
    markup.add(types.InlineKeyboardButton("âŸµã€ ğŸŒ€ ğ™±ğ™°ğ™²ğ™º ğŸŒ€ ã€âŸ¶", callback_data="admin_panel"))
    bot.edit_message_text(f"âœ… ğ‚ğ¨ğ¦ğ›ğ¨ ğğğ¥ğğ­ğğ: {flag} {name}", call.message.chat.id, call.message.message_id, reply_markup=markup)

@bot.callback_query_handler(func=lambda call: call.data == "admin_stats")
def admin_stats(call):
    if not is_admin(call.from_user.id):
        return
    total_users = len(get_all_users())
    combos = get_all_combos()
    total_numbers = sum(len(get_combo(c)) for c in combos)
    otp_count = len(get_otp_logs())
    markup = types.InlineKeyboardMarkup()
    markup.add(types.InlineKeyboardButton("âŸµã€ ğŸŒ€ ğ™±ğ™°ğ™²ğ™º ğŸŒ€ ã€âŸ¶", callback_data="admin_panel"))
    bot.edit_message_text(
        f"ğŸ“Š ğğ¨ğ­ ğ’ğ­ğšğ­ğ¬:\n"
        f"ğŸ‘¥ ğ€ğœğ­ğ¢ğ¯ğ ğ”ğ¬ğğ«ğ¬: {total_users}\n"
        f"ğŸŒ ğ‚ğ¨ğ®ğ§ğ­ğ«ğ¢ğğ¬ ğ€ğğğğ: {len(combos)}\n"
        f"ğŸ“ ğ“ğ¨ğ­ğšğ¥ ğğ®ğ¦ğ›ğğ«ğ¬: {total_numbers}\n"
        f"ğŸ”‘ ğ“ğ¨ğ­ğšğ¥ ğğ“ğğ¬ ğ‘ğğœğğ¢ğ¯ğğ: {otp_count}",
        call.message.chat.id, call.message.message_id, reply_markup=markup
    )

@bot.callback_query_handler(func=lambda call: call.data == "admin_full_report")
def admin_full_report(call):
    if not is_admin(call.from_user.id):
        return
    try:
        report = "ğŸ“Š ğ‚ğ¨ğ¦ğ©ğ¥ğğ­ğ ğğ¨ğ­ ğ‘ğğ©ğ¨ğ«ğ­\n" + "="*40 + "\n\n"
        report += "ğŸ‘¥ ğ”ğ¬ğğ«ğ¬:\n"
        conn = sqlite3.connect(DB_PATH)
        c = conn.cursor()
        c.execute("SELECT * FROM users")
        users = c.fetchall()
        for u in users:
            status = "ğğšğ§ğ§ğğ" if u[6] else "ğ€ğœğ­ğ¢ğ¯ğ"
            report += f"ID: {u[0]} | @{u[1] or 'N/A'} | Number: {u[5] or 'N/A'} | Status: {status}\n"
        report += "\n" + "="*40 + "\n\n"
        report += "ğŸ”‘ ğğ“ğ ğ‹ğ¨ğ ğ¬:\n"
        c.execute("SELECT * FROM otp_logs")
        logs = c.fetchall()
        for log in logs:
            user_info = get_user_info(log[5]) if log[5] else None
            user_tag = f"@{user_info[1]}" if user_info and user_info[1] else f"ID:{log[5] or 'N/A'}"
            report += f"Number: {log[1]} | OTP: {log[2]} | User: {user_tag} | Time: {log[4]}\n"
        conn.close()
        report += "\n" + "="*40 + "\n\n"
        report += "ğ‘ğğ©ğ¨ğ«ğ­ ğ ğğ§ğğ«ğšğ­ğğ ğšğ­: " + datetime.now().strftime("%Y-%m-%d %H:%M:%S")
        with open("bot_report.txt", "w", encoding="utf-8") as f:
            f.write(report)
        with open("bot_report.txt", "rb") as f:
            bot.send_document(call.from_user.id, f)
        os.remove("bot_report.txt")
        bot.answer_callback_query(call.id, "âœ… ğ‘ğğ©ğ¨ğ«ğ­ ğ¬ğğ§ğ­!", show_alert=True)
    except Exception as e:
        bot.answer_callback_query(call.id, f"âŒ ğ„ğ«ğ«ğ¨ğ«: {e}", show_alert=True)

@bot.callback_query_handler(func=lambda call: call.data == "admin_ban")
def admin_ban_step1(call):
    if not is_admin(call.from_user.id):
        return
    user_states[call.from_user.id] = "ban_user"
    markup = types.InlineKeyboardMarkup()
    markup.add(types.InlineKeyboardButton("âŸµã€ ğŸŒ€ ğ™±ğ™°ğ™²ğ™º ğŸŒ€ ã€âŸ¶", callback_data="admin_panel"))
    bot.edit_message_text("ğ„ğ§ğ­ğğ« ğ®ğ¬ğğ« ğˆğƒ ğ­ğ¨ ğ›ğšğ§:", call.message.chat.id, call.message.message_id, reply_markup=markup)

@bot.message_handler(func=lambda msg: user_states.get(msg.from_user.id) == "ban_user")
def admin_ban_step2(message):
    try:
        uid = int(message.text)
        ban_user(uid)
        bot.reply_to(message, f"âœ… ğ”ğ¬ğğ« {uid} ğ›ğšğ§ğ§ğğ")
        del user_states[message.from_user.id]
    except:
        bot.reply_to(message, "âŒ ğˆğ§ğ¯ğšğ¥ğ¢ğ ğˆğƒ!")

@bot.callback_query_handler(func=lambda call: call.data == "admin_unban")
def admin_unban_step1(call):
    if not is_admin(call.from_user.id):
        return
    user_states[call.from_user.id] = "unban_user"
    markup = types.InlineKeyboardMarkup()
    markup.add(types.InlineKeyboardButton("âŸµã€ ğŸŒ€ ğ™±ğ™°ğ™²ğ™º ğŸŒ€ ã€âŸ¶", callback_data="admin_panel"))
    bot.edit_message_text("ğ„ğ§ğ­ğğ« ğ®ğ¬ğğ« ğˆğƒ ğ­ğ¨ ğ®ğ§ğ›ğšğ§:", call.message.chat.id, call.message.message_id, reply_markup=markup)

@bot.message_handler(func=lambda msg: user_states.get(msg.from_user.id) == "unban_user")
def admin_unban_step2(message):
    try:
        uid = int(message.text)
        unban_user(uid)
        bot.reply_to(message, f"âœ… ğ”ğ¬ğğ« {uid} ğ®ğ§ğ›ğšğ§ğ§ğğ")
        del user_states[message.from_user.id]
    except:
        bot.reply_to(message, "âŒ ğˆğ§ğ¯ğšğ¥ğ¢ğ ğˆğƒ!")

@bot.callback_query_handler(func=lambda call: call.data == "admin_broadcast_all")
def admin_broadcast_all_step1(call):
    if not is_admin(call.from_user.id):
        return
    user_states[call.from_user.id] = "broadcast_all"
    markup = types.InlineKeyboardMarkup()
    markup.add(types.InlineKeyboardButton("âŸµã€ ğŸŒ€ ğ™±ğ™°ğ™²ğ™º ğŸŒ€ ã€âŸ¶", callback_data="admin_panel"))
    bot.edit_message_text("ğ’ğğ§ğ ğ¦ğğ¬ğ¬ğšğ ğ ğ­ğ¨ ğ›ğ«ğ¨ğšğğœğšğ¬ğ­ ğ­ğ¨ ğšğ¥ğ¥:", call.message.chat.id, call.message.message_id, reply_markup=markup)

@bot.message_handler(func=lambda msg: user_states.get(msg.from_user.id) == "broadcast_all")
def admin_broadcast_all_step2(message):
    users = get_all_users()
    success = 0
    for uid in users:
        try:
            bot.send_message(uid, message.text)
            success += 1
        except:
            pass
    bot.reply_to(message, f"âœ… ğ’ğğ§ğ­ ğ­ğ¨ {success}/{len(users)} ğ®ğ¬ğğ«ğ¬")
    del user_states[message.from_user.id]

@bot.callback_query_handler(func=lambda call: call.data == "admin_top_users")
def admin_top_users(call):
    if not is_admin(call.from_user.id):
        return
    
    top_users = get_top_otp_users(limit=10)
    
    if not top_users:
        text = "ğŸ“­ Ù„Ø§ ÙŠÙˆØ¬Ø¯ Ù…Ø³ØªØ®Ø¯Ù…ÙŠÙ† Ø­ØµÙ„ÙˆØ§ Ø¹Ù„Ù‰ OTPs Ø­ØªÙ‰ Ø§Ù„Ø¢Ù†."
    else:
        text = "<b>ğŸ† Ø£ÙƒØ«Ø± 10 Ù…Ø³ØªØ®Ø¯Ù…ÙŠÙ† Ø­ØµÙˆÙ„Ø§Ù‹ Ø¹Ù„Ù‰ OTPs:</b>\n\n"
        text += "<code>" + "=" * 40 + "</code>\n"
        text += "<b>ğŸ”¢ Ø§Ù„ØªØ±ØªÙŠØ¨ | ğŸ‘¤ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… | ğŸ“ Ø¹Ø¯Ø¯ OTPs</b>\n"
        text += "<code>" + "=" * 40 + "</code>\n"
        
        for idx, (user_id, username, first_name, count) in enumerate(top_users, 1):
            user_display = f"@{username}" if username else first_name or f"ID:{user_id}"
            text += f"<b>#{idx}</b>  |  <b>{user_display}</b>  |  ğŸ¯ <b>{count} OTP</b>\n"
    
    markup = types.InlineKeyboardMarkup()
    markup.add(types.InlineKeyboardButton("âŸµã€ ğŸŒ€ ğ™±ğ™°ğ™²ğ™º ğŸŒ€ ã€âŸ¶", callback_data="admin_panel"))
    
    # Ø§Ø³ØªØ®Ø¯Ø§Ù… HTML Ø¨Ø´ÙƒÙ„ Ø¢Ù…Ù†
    bot.edit_message_text(
        text,
        call.message.chat.id,
        call.message.message_id,
        reply_markup=markup,
        parse_mode="HTML"
    )

@bot.callback_query_handler(func=lambda call: call.data == "accept_terms")
def handle_accept_terms(call):
    user_id = call.from_user.id
    
    # Ø­ÙØ¸ Ø§Ù„Ù…ÙˆØ§ÙÙ‚Ø©
    USER_AGREEMENTS[user_id] = True
    save_user_agreement(user_id)
    
    # ØªØ¹Ø¯ÙŠÙ„ Ø§Ù„Ø±Ø³Ø§Ù„Ø© Ø§Ù„Ø­Ø§Ù„ÙŠØ©
    bot.answer_callback_query(call.id, "âœ… ØªÙ… Ù‚Ø¨ÙˆÙ„ Ø§Ù„Ø´Ø±ÙˆØ· Ø¨Ù†Ø¬Ø§Ø­")
    
    # ØªØ­Ù‚Ù‚ Ù…Ù† Ø§Ù„Ø§Ø´ØªØ±Ø§Ùƒ ÙÙŠ Ø§Ù„Ù‚Ù†ÙˆØ§Øª
    if not force_sub_check(user_id):
        markup = force_sub_markup()
        if markup:
            subscription_text = """
<b>ğŸš« <u>ÙŠØ¬Ø¨ Ø§Ù„Ø§Ø´ØªØ±Ø§Ùƒ ÙÙŠ Ø§Ù„Ù‚Ù†ÙˆØ§Øª</u></b>

<i>ğŸ“¢ Ù„Ù„Ø§Ø³ØªÙ…Ø±Ø§Ø±ØŒ ÙŠØ±Ø¬Ù‰ Ø§Ù„Ø§Ø´ØªØ±Ø§Ùƒ ÙÙŠ Ø¬Ù…ÙŠØ¹ Ø§Ù„Ù‚Ù†ÙˆØ§Øª Ø«Ù… Ø§Ù„Ø¶ØºØ· Ø¹Ù„Ù‰ "Ø§Ù„ØªØ­Ù‚Ù‚"</i>

<code>â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”</code>
"""
            try:
                bot.edit_message_text(
                    chat_id=call.message.chat.id,
                    message_id=call.message.message_id,
                    text=subscription_text,
                    parse_mode="HTML",
                    reply_markup=markup
                )
            except:
                bot.send_message(call.message.chat.id, subscription_text, parse_mode="HTML", reply_markup=markup)
    else:
        # Ø¥Ø°Ø§ Ù…Ø´ØªØ±Ùƒ Ø¨Ø§Ù„ÙØ¹Ù„ØŒ Ø¹Ø±Ø¶ Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ø¯ÙˆÙ„ Ù…Ø¨Ø§Ø´Ø±Ø©
        success_text = """
<b>âœ… <u>ØªÙ… ØªÙØ¹ÙŠÙ„ Ø­Ø³Ø§Ø¨Ùƒ Ø¨Ù†Ø¬Ø§Ø­!</u></b>

<i>ğŸ‰ ÙŠÙ…ÙƒÙ†Ùƒ Ø§Ù„Ø¢Ù† Ø§Ø®ØªÙŠØ§Ø± Ø§Ù„Ø¯ÙˆÙ„Ø© Ù„Ø¨Ø¯Ø¡ Ø§Ø³ØªÙ‚Ø¨Ø§Ù„ Ø§Ù„Ø±Ø³Ø§Ø¦Ù„</i>

<code>â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”</code>
"""
        try:
            bot.edit_message_text(
                chat_id=call.message.chat.id,
                message_id=call.message.message_id,
                text=success_text,
                parse_mode="HTML"
            )
        except:
            pass
        
        # Ø§Ù†ØªØ¸Ø± Ø«Ø§Ù†ÙŠØ© Ø«Ù… Ø£Ø±Ø³Ù„ Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ø¯ÙˆÙ„
        time.sleep(1)
        markup = types.InlineKeyboardMarkup()
        user = get_user(user_id)
        private_combo = user[7] if user else None
        all_combos = get_all_combos()

        if is_admin(user_id):
            markup.add(types.InlineKeyboardButton("ğŸ” ğ€ğƒğŒğˆğ ğğ€ğğ„ğ‹ğ–¤›", callback_data="admin_panel"))

        if private_combo and private_combo in COUNTRY_CODES:
            name, flag, _ = COUNTRY_CODES[private_combo]
            markup.add(types.InlineKeyboardButton(f"{flag} {name} (Private)", callback_data=f"country_{private_combo}"))

        for code in all_combos:
            if code in COUNTRY_CODES and code != private_combo:
                name, flag, _ = COUNTRY_CODES[code]
                markup.add(types.InlineKeyboardButton(f"{flag} {name}", callback_data=f"country_{code}"))

        row_buttons = [
            types.InlineKeyboardButton("ğ¨ğ­ğ©", url="https://t.me/otp_bemer")
        ]
        bot.send_message(call.message.chat.id, "ğŸŒ ğ‘ºğ‘¬ğ‘³ğ‘¬ğ‘ªğ‘» ğ’€ğ‘¶ğ‘¼ğ‘¹ ğ‘ªğ‘¶ğ‘¼ğ‘µğ‘»ğ‘¹ğ’€ğ–¥µ:", reply_markup=markup)

@bot.callback_query_handler(func=lambda call: call.data == "admin_broadcast_user")
def admin_broadcast_user_step1(call):
    if not is_admin(call.from_user.id):
        return
    user_states[call.from_user.id] = "broadcast_user_id"
    markup = types.InlineKeyboardMarkup()
    markup.add(types.InlineKeyboardButton("âŸµã€ ğŸŒ€ ğ™±ğ™°ğ™²ğ™º ğŸŒ€ ã€âŸ¶", callback_data="admin_panel"))
    bot.edit_message_text("ğ„ğ§ğ­ğğ« ğ®ğ¬ğğ« ğˆğƒ:", call.message.chat.id, call.message.message_id, reply_markup=markup)

@bot.message_handler(func=lambda msg: user_states.get(msg.from_user.id) == "broadcast_user_id")
def admin_broadcast_user_step2(message):
    try:
        uid = int(message.text)
        user_states[message.from_user.id] = f"broadcast_msg_{uid}"
        bot.reply_to(message, "ğ’ğğ§ğ ğ¦ğğ¬ğ¬ğšğ ğ:")
    except:
        bot.reply_to(message, "âŒ ğˆğ§ğ¯ğšğ¥ğ¢ğ ğˆğƒ!")

@bot.message_handler(func=lambda msg: user_states.get(msg.from_user.id, "").startswith("broadcast_msg_"))
def admin_broadcast_user_step3(message):
    uid = int(user_states[message.from_user.id].split("_")[2])
    try:
        bot.send_message(uid, message.text)
        bot.reply_to(message, f"âœ… ğŒğğ¬ğ¬ğšğ ğ ğ¬ğğ§ğ­ ğ­ğ¨ ğ®ğ¬ğğ« {uid}")
    except Exception as e:
        bot.reply_to(message, f"âŒ ğ…ğšğ¢ğ¥ğğ: {e}")
    del user_states[message.from_user.id]

@bot.callback_query_handler(func=lambda call: call.data == "admin_user_info")
def admin_user_info_step1(call):
    if not is_admin(call.from_user.id):
        return
    user_states[call.from_user.id] = "get_user_info"
    markup = types.InlineKeyboardMarkup()
    markup.add(types.InlineKeyboardButton("âŸµã€ ğŸŒ€ ğ™±ğ™°ğ™²ğ™º ğŸŒ€ ã€âŸ¶", callback_data="admin_panel"))
    bot.edit_message_text("ğ„ğ§ğ­ğğ« ğ®ğ¬ğğ« ğˆğƒ:", call.message.chat.id, call.message.message_id, reply_markup=markup)

@bot.message_handler(func=lambda msg: user_states.get(msg.from_user.id) == "get_user_info")
def admin_user_info_step2(message):
    try:
        uid = int(message.text)
        user = get_user_info(uid)
        if not user:
            bot.reply_to(message, "âŒ ğ”ğ¬ğğ« ğ§ğ¨ğ­ ğŸğ¨ğ®ğ§ğ!")
            return
        status = "ğğšğ§ğ§ğğ" if user[6] else "ğ€ğœğ­ğ¢ğ¯ğ"
        info = f"ğŸ‘¤ ğ”ğ¬ğğ« ğˆğ§ğŸğ¨:\n"
        info += f"ğŸ†”: {user[0]}\n"
        info += f"Username: @{user[1] or 'N/A'}\n"
        info += f"Name: {user[2] or ''} {user[3] or ''}\n"
        info += f"Assigned Number: {user[5] or 'N/A'}\n"
        info += f"Status: {status}"
        bot.reply_to(message, info)
    except Exception as e:
        bot.reply_to(message, f"âŒ ğ„ğ«ğ«ğ¨ğ«: {e}")
    del user_states[message.from_user.id]

@bot.message_handler(func=lambda msg: user_states.get(msg.from_user.id) == "set_force_sub_channel")
def admin_set_force_sub_channel_step2(message):
    channel = message.text.strip()
    if not (channel.startswith("@") or channel.startswith("https://t.me/")):
        bot.reply_to(message, "âŒ ğˆğ§ğ¯ğšğ¥ğ¢ğ ğ¥ğ¢ğ§ğ¤! ğŒğ®ğ¬ğ­ ğ¬ğ­ğšğ«ğ­ ğ°ğ¢ğ­ğ¡ @ ğ¨ğ« https://t.me/")
        return
    set_setting("force_sub_channel", channel)
    bot.reply_to(message, f"âœ… ğ‚ğ¡ğšğ§ğ§ğğ¥ ğ¬ğğ­: {channel}")
    del user_states[message.from_user.id]

@bot.callback_query_handler(func=lambda call: call.data == "admin_enable_force_sub")
def admin_enable_force_sub(call):
    set_setting("force_sub_enabled", "1")
    bot.answer_callback_query(call.id, "âœ… ğ…ğ¨ğ«ğœğ ğ¬ğ®ğ›ğ¬ğœğ«ğ¢ğ©ğ­ğ¢ğ¨ğ§ ğğ§ğšğ›ğ¥ğğ!", show_alert=True)
    admin_force_sub(call)

@bot.callback_query_handler(func=lambda call: call.data == "admin_disable_force_sub")
def admin_disable_force_sub(call):
    set_setting("force_sub_enabled", "0")
    bot.answer_callback_query(call.id, "âŒ ğ…ğ¨ğ«ğœğ ğ¬ğ®ğ›ğ¬ğœğ«ğ¢ğ©ğ­ğ¢ğ¨ğ§ ğğ¢ğ¬ğšğ›ğ¥ğğ!", show_alert=True)
    admin_force_sub(call)

def get_dashboards():
    conn = sqlite3.connect(DB_PATH)
    c = conn.cursor()
    c.execute("SELECT * FROM dashboards")
    rows = c.fetchall()
    conn.close()
    return rows

def save_dashboard(base_url, ajax_path, login_page, login_post, username, password):
    conn = sqlite3.connect(DB_PATH)
    c = conn.cursor()
    c.execute("""INSERT INTO dashboards (base_url, ajax_path, login_page, login_post, username, password)
                 VALUES (?, ?, ?, ?, ?, ?)""",
              (base_url, ajax_path, login_page, login_post, username, password))
    conn.commit()
    conn.close()

def delete_dashboard(dash_id):
    conn = sqlite3.connect(DB_PATH)
    c = conn.cursor()
    c.execute("DELETE FROM dashboards WHERE id=?", (dash_id,))
    conn.commit()
    conn.close()

@bot.callback_query_handler(func=lambda call: call.data == "admin_dashboards")
def admin_dashboards(call):
    if not is_admin(call.from_user.id):
        return
    dashboards = get_dashboards()
    markup = types.InlineKeyboardMarkup()
    if dashboards:
        for d in dashboards:
            markup.add(types.InlineKeyboardButton(f"ğƒğšğ¬ğ¡ğ›ğ¨ğšğ«ğ {d[0]}", callback_data=f"view_dashboard_{d[0]}"))
    markup.add(types.InlineKeyboardButton("â• ğ€ğğ ğƒğšğ¬ğ¡ğ›ğ¨ğšğ«ğ", callback_data="add_dashboard"))
    markup.add(types.InlineKeyboardButton("âŸµã€ ğŸŒ€ ğ™±ğ™°ğ™²ğ™º ğŸŒ€ ã€âŸ¶", callback_data="admin_panel"))
    bot.edit_message_text("ğŸ–¥ï¸ ğƒğšğ¬ğ¡ğ›ğ¨ğšğ«ğğ¬:", call.message.chat.id, call.message.message_id, reply_markup=markup)

@bot.callback_query_handler(func=lambda call: call.data.startswith("view_dashboard_"))
def view_dashboard(call):
    dash_id = int(call.data.split("_")[2])
    dashboards = get_dashboards()
    dash = next((d for d in dashboards if d[0] == dash_id), None)
    if not dash:
        bot.answer_callback_query(call.id, "âŒ ğƒğšğ¬ğ¡ğ›ğ¨ğšğ«ğ ğ§ğ¨ğ­ ğŸğ¨ğ®ğ§ğ!")
        return
    text = f"ğƒğšğ¬ğ¡ğ›ğ¨ğšğ«ğ {dash_id}:\nBase: {dash[1]}\nUsername: {dash[5]}"
    markup = types.InlineKeyboardMarkup()
    markup.add(types.InlineKeyboardButton("ğŸ—‘ï¸ ğƒğğ¥ğğ­ğ", callback_data=f"del_dashboard_{dash_id}"))
    markup.add(types.InlineKeyboardButton("âŸµã€ ğŸŒ€ ğ™±ğ™°ğ™²ğ™º ğŸŒ€ ã€âŸ¶", callback_data="admin_dashboards"))
    bot.edit_message_text(text, call.message.chat.id, call.message.message_id, reply_markup=markup)

@bot.callback_query_handler(func=lambda call: call.data.startswith("del_dashboard_"))
def del_dashboard(call):
    dash_id = int(call.data.split("_")[2])
    delete_dashboard(dash_id)
    bot.answer_callback_query(call.id, "âœ… ğƒğğ¥ğğ­ğğ!", show_alert=True)
    admin_dashboards(call)

@bot.callback_query_handler(func=lambda call: call.data == "add_dashboard")
def add_dashboard_step1(call):
    if not is_admin(call.from_user.id):
        return
    user_states[call.from_user.id] = "add_dash_base"
    markup = types.InlineKeyboardMarkup()
    markup.add(types.InlineKeyboardButton("âŸµã€ ğŸŒ€ ğ™±ğ™°ğ™²ğ™º ğŸŒ€ ã€âŸ¶", callback_data="admin_dashboards"))
    bot.edit_message_text("ğ„ğ§ğ­ğğ« ğğšğ¬ğ ğ”ğ‘ğ‹:", call.message.chat.id, call.message.message_id, reply_markup=markup)

@bot.message_handler(func=lambda msg: user_states.get(msg.from_user.id) == "add_dash_base")
def add_dashboard_step2(message):
    user_states[message.from_user.id] = {"step": "ajax", "base": message.text}
    bot.reply_to(message, "ğ„ğ§ğ­ğğ« ğ€ğ‰ğ€ğ— ğğšğ­ğ¡:")

@bot.message_handler(func=lambda msg:
                    isinstance(user_states.get(msg.from_user.id), dict) and
                    user_states[msg.from_user.id].get("step") == "ajax")
def add_dashboard_step3(message):
    user_states[message.from_user.id]["ajax"] = message.text
    user_states[message.from_user.id]["step"] = "login_page"
    bot.reply_to(message, "ğ„ğ§ğ­ğğ« ğ‹ğ¨ğ ğ¢ğ§ ğğšğ ğ ğ”ğ‘ğ‹:")

@bot.message_handler(func=lambda msg:
                    isinstance(user_states.get(msg.from_user.id), dict) and
                    user_states[msg.from_user.id].get("step") == "login_page")
def add_dashboard_step4(message):
    user_states[message.from_user.id]["login_page"] = message.text
    user_states[message.from_user.id]["step"] = "login_post"
    bot.reply_to(message, "ğ„ğ§ğ­ğğ« ğ‹ğ¨ğ ğ¢ğ§ ğğğ’ğ“ ğ”ğ‘ğ‹:")

@bot.message_handler(func=lambda msg:
                    isinstance(user_states.get(msg.from_user.id), dict) and
                    user_states[msg.from_user.id].get("step") == "login_post")
def add_dashboard_step5(message):
    user_states[message.from_user.id]["login_post"] = message.text
    user_states[message.from_user.id]["step"] = "username"
    bot.reply_to(message, "ğ„ğ§ğ­ğğ« ğ”ğ¬ğğ«ğ§ğšğ¦ğ:")

@bot.message_handler(func=lambda msg:
                    isinstance(user_states.get(msg.from_user.id), dict) and
                    user_states[msg.from_user.id].get("step") == "username")
def add_dashboard_step6(message):
    user_states[message.from_user.id]["username"] = message.text
    user_states[message.from_user.id]["step"] = "password"
    bot.reply_to(message, "ğ„ğ§ğ­ğğ« ğğšğ¬ğ¬ğ°ğ¨ğ«ğ:")

@bot.message_handler(func=lambda msg:
                    isinstance(user_states.get(msg.from_user.id), dict) and
                    user_states[msg.from_user.id].get("step") == "password")
def add_dashboard_step7(message):
    try:
        data = user_states[message.from_user.id]
        save_dashboard(
            data["base"],
            data["ajax"],
            data["login_page"],
            data["login_post"],
            data["username"],
            message.text
        )
        bot.reply_to(message, "âœ… ğƒğšğ¬ğ¡ğ›ğ¨ğšğ«ğ ğšğğğğ ğ¬ğ®ğœğœğğ¬ğ¬ğŸğ®ğ¥ğ¥ğ²!")
    except Exception as e:
        bot.reply_to(message, f"âŒ ğ„ğ«ğ«ğ¨ğ« ğ¬ğšğ¯ğ¢ğ§ğ  ğğšğ¬ğ¡ğ›ğ¨ğšğ«ğ: {e}")
    finally:
        del user_states[message.from_user.id]




@bot.callback_query_handler(func=lambda call: call.data == "admin_private_combo")
def admin_private_combo(call):
    if not is_admin(call.from_user.id):
        return
    markup = types.InlineKeyboardMarkup()
    markup.add(types.InlineKeyboardButton("â• Ø¥Ø¶Ø§ÙØ© ÙƒÙˆÙ…Ø¨Ùˆ Ø¨Ø±Ø§ÙŠÙØª", callback_data="add_private_combo"))
    markup.add(types.InlineKeyboardButton("ğŸ—‘ï¸ Ù…Ø³Ø­ ÙƒÙˆÙ…Ø¨Ùˆ Ø¨Ø±Ø§ÙŠÙØª", callback_data="del_private_combo"))
    markup.add(types.InlineKeyboardButton("âŸµã€ ğŸŒ€ ğ™±ğ™°ğ™²ğ™º ğŸŒ€ ã€âŸ¶", callback_data="admin_panel"))
    bot.edit_message_text("ğŸ‘¤ ÙƒÙˆÙ…Ø¨Ùˆ Ø¨Ø±Ø§ÙŠÙØª:", call.message.chat.id, call.message.message_id, reply_markup=markup)

@bot.callback_query_handler(func=lambda call: call.data == "add_private_combo")
def add_private_combo_step1(call):
    if not is_admin(call.from_user.id):
        return
    user_states[call.from_user.id] = "add_private_user_id"
    markup = types.InlineKeyboardMarkup()
    markup.add(types.InlineKeyboardButton("âŸµã€ ğŸŒ€ ğ™±ğ™°ğ™²ğ™º ğŸŒ€ ã€âŸ¶", callback_data="admin_private_combo"))
    bot.edit_message_text("Ø£Ø¯Ø®Ù„ Ù…Ø¹Ø±Ù Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…:", call.message.chat.id, call.message.message_id, reply_markup=markup)

@bot.message_handler(func=lambda msg: user_states.get(msg.from_user.id) == "add_private_user_id")
def add_private_combo_step2(message):
    try:
        uid = int(message.text)
        user_states[message.from_user.id] = f"add_private_country_{uid}"
        markup = types.InlineKeyboardMarkup(row_width=2)
        buttons = []
        for code in get_all_combos():
            if code in COUNTRY_CODES:
                name, flag, _ = COUNTRY_CODES[code]
                buttons.append(types.InlineKeyboardButton(f"{flag} {name}", callback_data=f"select_private_{uid}_{code}"))
        for i in range(0, len(buttons), 2):
            markup.row(*buttons[i:i+2])
        markup.add(types.InlineKeyboardButton("âŸµã€ ğŸŒ€ ğ™±ğ™°ğ™²ğ™º ğŸŒ€ ã€âŸ¶", callback_data="admin_private_combo"))
        bot.reply_to(message, "Ø§Ø®ØªØ± Ø§Ù„Ø¯ÙˆÙ„Ø©:", reply_markup=markup)
    except:
        bot.reply_to(message, "âŒ Ù…Ø¹Ø±Ù ØºÙŠØ± ØµØ­ÙŠØ­!")

@bot.callback_query_handler(func=lambda call: call.data.startswith("select_private_"))
def select_private_combo(call):
    parts = call.data.split("_")
    uid = int(parts[2])
    country_code = parts[3]
    save_user(uid, private_combo_country=country_code)
    name, flag, _ = COUNTRY_CODES[country_code]
    bot.answer_callback_query(call.id, f"âœ… ØªÙ… ØªØ¹ÙŠÙŠÙ† ÙƒÙˆÙ…Ø¨Ùˆ Ø¨Ø±Ø§ÙŠÙØª Ù„Ù€ {uid} - {flag} {name}", show_alert=True)
    admin_private_combo(call)

@bot.callback_query_handler(func=lambda call: call.data == "del_private_combo")
def del_private_combo_step1(call):
    if not is_admin(call.from_user.id):
        return
    user_states[call.from_user.id] = "del_private_user_id"
    markup = types.InlineKeyboardMarkup()
    markup.add(types.InlineKeyboardButton("âŸµã€ ğŸŒ€ ğ™±ğ™°ğ™²ğ™º ğŸŒ€ ã€âŸ¶", callback_data="admin_private_combo"))
    bot.edit_message_text("Ø£Ø¯Ø®Ù„ Ù…Ø¹Ø±Ù Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…:", call.message.chat.id, call.message.message_id, reply_markup=markup)

@bot.message_handler(func=lambda msg: user_states.get(msg.from_user.id) == "del_private_user_id")
def del_private_combo_step2(message):
    try:
        uid = int(message.text)
        save_user(uid, private_combo_country=None)
        bot.reply_to(message, f"âœ… ØªÙ… Ù…Ø³Ø­ Ø§Ù„ÙƒÙˆÙ…Ø¨Ùˆ Ø§Ù„Ø¨Ø±Ø§ÙŠÙØª Ù„Ù„Ù…Ø³ØªØ®Ø¯Ù… {uid}")
    except:
        bot.reply_to(message, "âŒ Ù…Ø¹Ø±Ù ØºÙŠØ± ØµØ­ÙŠØ­!")
    del user_states[message.from_user.id]

@bot.callback_query_handler(func=lambda call: call.data == "admin_refresh_combo")
def admin_refresh_combo(call):
    if not is_admin(call.from_user.id):
        return

    markup = types.InlineKeyboardMarkup()
    markup.add(types.InlineKeyboardButton("âŸµã€ ğŸŒ€ ğ™±ğ™°ğ™²ğ™º ğŸŒ€ ã€âŸ¶", callback_data="admin_panel"))

    bot.edit_message_text(
        "ğŸ”„ Ù„Ø¥Ø¹Ø§Ø¯Ø© ØªØ¹Ø¨Ø¦Ø© Ø§Ù„ÙƒÙˆÙ…Ø¨Ùˆ:\n"
        "1. Ø£Ø±Ø³Ù„ Ù…Ù„Ù ÙƒÙˆÙ…Ø¨Ùˆ Ø¬Ø¯ÙŠØ¯\n"
        "2. Ø³ØªØ­Ù„ Ø§Ù„Ø£Ø±Ù‚Ø§Ù… Ø§Ù„Ø¬Ø¯ÙŠØ¯Ø© Ù…Ø­Ù„ Ø§Ù„Ù‚Ø¯ÙŠÙ…Ø©\n"
        "3. Ø§Ù„Ø£Ø±Ù‚Ø§Ù… Ø§Ù„ØªÙŠ ÙˆØµÙ„Ù‡Ø§ ÙƒÙˆØ¯ Ù„Ù† ØªØ¹ÙˆØ¯",
        call.message.chat.id, call.message.message_id, reply_markup=markup
    )




def get_available_numbers(country_code, user_id=None):
    """
    ØªØ±Ø¬Ø¹ Ø§Ù„Ø£Ø±Ù‚Ø§Ù… Ø§Ù„Ù…ØªØ§Ø­Ø© (ØºÙŠØ± Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…Ø©) Ù…Ù† Ø§Ù„ÙƒÙˆÙ…Ø¨Ùˆ
    Ù…Ø¹ Ù…Ø±Ø§Ø¹Ø§Ø© Ø£Ù† Ø¨Ø¹Ø¶ Ø§Ù„Ø£Ø±Ù‚Ø§Ù… Ù‚Ø¯ ØªÙ… Ø­Ø°ÙÙ‡Ø§ Ø³Ø§Ø¨Ù‚Ø§Ù‹
    """
    all_numbers = get_combo(country_code, user_id)
    if not all_numbers:
        return []

    conn = sqlite3.connect(DB_PATH)
    c = conn.cursor()


    c.execute("SELECT assigned_number FROM users WHERE assigned_number IS NOT NULL AND assigned_number != ''")
    used_numbers = set(row[0] for row in c.fetchall())


    c.execute("SELECT DISTINCT number FROM otp_logs")
    otp_numbers = set(row[0] for row in c.fetchall())

    conn.close()


    forbidden_numbers = used_numbers.union(otp_numbers)


    available = [num for num in all_numbers if num not in forbidden_numbers]

    return available




def send_otp_to_user_and_group(date_str, number, sms):
    otp_code = extract_otp(sms)
    user_id = get_user_by_number(number)


    log_otp(number, otp_code, sms, user_id)

    if user_id:
        try:
            service = detect_service(sms)
            bot.send_message(
                user_id,
                f"â˜ï¸*ğ˜ğ¨ğ®ğ« ğğ®ğ¦ğ›ğğ«:* {number}\nğŸ”‘*ğğ“ğ:* {otp_code}\nğŸ’¬ *ğ’ğğ«ğ¯ğ¢ğœğ* : {service}\n\nâš ï¸ *Ù…Ù„Ø­ÙˆØ¸Ø©:* ØªÙ… Ø¥Ø²Ø§Ù„Ø© Ù‡Ø°Ø§ Ø§Ù„Ø±Ù‚Ù… Ù…Ù† Ø§Ù„ÙƒÙˆÙ…Ø¨Ùˆ",
                parse_mode="Markdown"
            )
        except Exception as e:
            print(f"[!] ÙØ´Ù„ Ø¥Ø±Ø³Ø§Ù„ OTP Ù„Ù„Ù…Ø³ØªØ®Ø¯Ù… {user_id}: {e}")

    msg = format_message(date_str, number, sms)
    send_to_telegram_group(msg, otp_code)




def load_cache():
    try:
        with open(CACHE_FILE, 'r') as f:
            return set(json.load(f))
    except:
        return set()

def save_cache(cache):
    with open(CACHE_FILE, 'w') as f:
        json.dump(list(cache), f)

def get_country_info(number):
    number = re.sub(r'\D', '', str(number))
    sorted_codes = sorted(COUNTRY_CODES.keys(), key=len, reverse=True)
    for code in sorted_codes:
        if number.startswith(code):
            name, flag, _ = COUNTRY_CODES[code]
            return name, flag
    return "Unknown", "ğŸŒ"

def extract_otp_api(msg):
    patterns = [
        r'(\d{6})',
        r'(\d{4}[-\s]?\d{2})',
        r'(\d{3}[-\s]?\d{3})',
        r'(?:code|Ø±Ù…Ø²|ÙƒÙˆØ¯)[:\s]+(\d{4,8})',
    ]
    for p in patterns:
        m = re.search(p, msg, re.IGNORECASE)
        if m:
            otp = re.sub(r'\D', '', m.group(1))
            return f"{otp[:3]} {otp[3:]}" if len(otp) > 3 else otp
    return None

def detect_service_api(msg):
    keywords_map = {
        "WHATSAPP": ["whatsapp", "ÙˆØ§ØªØ³Ø§Ø¨", "ÙˆØ§ØªØ³"],
        "FACEBOOK": ["facebook", "ÙÙŠØ³Ø¨ÙˆÙƒ", "fb"],
        "INSTAGRAM": ["instagram", "Ø§Ù†Ø³ØªÙ‚Ø±Ø§Ù…", "Ø§Ù†Ø³ØªØ§"],
        "TELEGRAM": ["telegram", "ØªÙŠÙ„ÙŠØ¬Ø±Ø§Ù…"],
        "TWITTER": ["twitter", "ØªÙˆÙŠØªØ±"],
        "GOOGLE": ["google", "gmail", "Ø¬ÙˆØ¬Ù„"],
        "DISCORD": ["discord"],
        "LINE": ["line"],
        "VIBER": ["viber"],
        "SKYPE": ["skype"],
        "SNAPCHAT": ["snapchat"],
        "TIKTOK": ["tiktok", "tik tok"],
        "AMAZON": ["amazon"],
        "APPLE": ["apple"],
        "MICROSOFT": ["microsoft"],
        "LINKEDIN": ["linkedin"],
        "UBER": ["uber"],
        "AIRBNB": ["airbnb", "air bnb"],
        "NETFLIX": ["netflix"],
        "SPOTIFY": ["spotify"],
        "YOUTUBE": ["youtube"],
        "GITHUB": ["github"],
        "PINTEREST": ["pinterest"],
        "PAYPAL": ["paypal"],
        "BOOKING": ["booking"],
    }
    msg_lower = msg.lower()
    for service, keywords in keywords_map.items():
        for kw in keywords:
            if kw in msg_lower:
                return service
    return "SMS"

def mask_number_api(number):
    if len(number) > 8:
        return number[:3] + "â€¢â€¢" + number[-4:]
    return number

def format_api_message(code):
    number = code.get('number', '')
    sms = code.get('sms', '')

    country_name, country_flag = get_country_info(number)
    service = detect_service_api(sms)
    otp = extract_otp_api(sms)
    otp_clean = re.sub(r'\D', '', otp) if otp else ""
    masked = mask_number_api(number)


    country_code = ""
    clean_num = re.sub(r'\D', '', str(number))
    sorted_codes = sorted(COUNTRY_CODES.keys(), key=len, reverse=True)
    for code in sorted_codes:
        if clean_num.startswith(code):
            country_code = f"#{code}"
            break


    service_short = ""
    msg_lower = sms.lower()
    service_mapping = {
        "#WS": ["whatsapp", "ÙˆØ§ØªØ³Ø§Ø¨", "ÙˆØ§ØªØ³"],
        "#FB": ["facebook", "ÙÙŠØ³Ø¨ÙˆÙƒ", "fb"],
        "#IG": ["instagram", "Ø§Ù†Ø³ØªÙ‚Ø±Ø§Ù…", "Ø§Ù†Ø³ØªØ§"],
        "#TG": ["telegram", "ØªÙŠÙ„ÙŠØ¬Ø±Ø§Ù…"],
        "#TW": ["twitter", "ØªÙˆÙŠØªØ±"],
        "#GG": ["google", "gmail", "Ø¬ÙˆØ¬Ù„"],
        "#DC": ["discord"],
        "#LN": ["line"],
        "#VB": ["viber"],
        "#SK": ["skype"],
        "#SC": ["snapchat"],
        "#TT": ["tiktok", "tik tok"],
        "#AMZ": ["amazon"],
        "#APL": ["apple"],
        "#MS": ["microsoft"],
        "#IN": ["linkedin"],
        "#UB": ["uber"],
        "#AB": ["airbnb", "air bnb"],
        "#NF": ["netflix"],
        "#SP": ["spotify"],
        "#YT": ["youtube"],
        "#GH": ["github"],
        "#PT": ["pinterest"],
        "#PP": ["paypal"],
        "#BK": ["booking"],
    }

    for service_code, keywords in service_mapping.items():
        for kw in keywords:
            if kw in msg_lower:
                service_short = service_code
                break
        if service_short:
            break

    if not service_short:
        service_short = "#unknown"


    country_short = country_name.upper()[:2] if len(country_name) > 1 else country_name.upper()


    msg = f"<b>ğŸ¯ ğ’ğŒğ’ ğ‘ğ„ğ‚ğ„ğˆğ•ğ„ğƒ</b>\n{country_flag}{country_short}\nâ˜ï¸ğğ®ğ¦ğ›ğğ«: {masked}\nğŸ’¬ ğ’ğğ«ğ¯ğ¢ğœğ :{service_short}"

    return msg, otp_clean

def get_all_codes_api():
    try:
        params = {
            'api_key': API_KEY,
            'username': USERNAME,
            'password': PASSWORD,
            '_t': int(time.time() * 1000)
        }
        resp = requests.get(API_URL, params=params, timeout=25)
        data = resp.json()

        if data.get('success') and data.get('codes'):
            codes = data['codes']


            for code in codes:
                number = code.get('number', '')
                sms = code.get('sms', '')
                otp = extract_otp_api(sms)

                if otp and number:

                    cleaned_number = clean_number(number)
                    country_code = None

                    for code in COUNTRY_CODES:
                        if cleaned_number.startswith(code):
                            country_code = code
                            break

                    if country_code:

                        user_id = get_user_by_number(number)
                        if user_id:
                            user = get_user(user_id)

                            if user and user[7] == country_code:
                                delete_number_from_combo(number, country_code, user_id)


                        delete_number_from_combo(number, country_code)

            return codes
        return []
    except Exception as e:
        print(f"API error: {e}")
        return []




def extract_otp(message):
    patterns = [
        r'(?:code|Ø±Ù…Ø²|ÙƒÙˆØ¯|verification|ØªØ­Ù‚Ù‚|otp|pin)[:\s]+[â€]?(\d{3,8}(?:[- ]\d{3,4})?)',
        r'(\d{3})[- ](\d{3,4})',
        r'\b(\d{4,8})\b',
        r'[â€](\d{3,8})',
    ]
    for pattern in patterns:
        match = re.search(pattern, message, re.IGNORECASE)
        if match:
            if len(match.groups()) > 1:
                return ''.join(match.groups())
            return match.group(1).replace(' ', '').replace('-', '')
    all_numbers = re.findall(r'\d{4,8}', message)
    if all_numbers:
        return all_numbers[0]
    return "N/A"

def detect_service(message):
    message_lower = message.lower()
    services = {
        "#WS": ["whatsapp", "ÙˆØ§ØªØ³Ø§Ø¨", "ÙˆØ§ØªØ³"],
        "#FB": ["facebook", "ÙÙŠØ³Ø¨ÙˆÙƒ", "fb"],
        "#IG": ["instagram", "Ø§Ù†Ø³ØªÙ‚Ø±Ø§Ù…", "Ø§Ù†Ø³ØªØ§"],
        "#TG": ["telegram", "ØªÙŠÙ„ÙŠØ¬Ø±Ø§Ù…"],
        "#TW": ["twitter", "ØªÙˆÙŠØªØ±"],
        "#GG": ["google", "gmail", "Ø¬ÙˆØ¬Ù„"],
        "#DC": ["discord"],
        "#LN": ["line"],
        "#VB": ["viber"],
        "#SK": ["skype"],
        "#SC": ["snapchat"],
        "#TT": ["tiktok", "tik tok"],
        "#AMZ": ["amazon"],
        "#APL": ["apple"],
        "#MS": ["microsoft"],
        "#IN": ["linkedin"],
        "#UB": ["uber"],
        "#AB": ["airbnb", "air bnb"],
        "#NF": ["netflix"],
        "#SP": ["spotify"],
        "#YT": ["youtube"],
        "#GH": ["github"],
        "#PT": ["pinterest"],
        "#PP": ["paypal"],
        "#BK": ["booking"],
    }
    for service, keywords in services.items():
        for keyword in keywords:
            if keyword in message_lower:
                return service.upper()
    return "GENERAL"

def send_telegram(text, otp_code):
    try:
        url = f"https://api.telegram.org/bot{BOT_TOKEN}/sendMessage"
        keyboard = {
            "inline_keyboard": [
                [
                    {"text": "Ø¨ÙˆØª Ø§Ù„Ø§Ø±Ù‚Ø§Ù…â¬¥ ğŸ“£", "url": "http://t.me/Uxhuxuxuxbot"},
                ],
                [
                    {
                        "text": otp_code,
                        "copy_text": {"text": otp_code}
                    }
                ]
            ]
        }
        success_count = 0

        for chat_id in CHAT_IDS:
            try:
                payload = {
                    "chat_id": chat_id,
                    "text": text,
                    "parse_mode": "HTML",
                    "reply_markup": json.dumps(keyboard)
                }
                resp = requests.post(url, data=payload, timeout=10)
                if resp.status_code != 200:
                    print(f"[!] ÙØ´Ù„ Ø¥Ø±Ø³Ø§Ù„ Ø¥Ù„Ù‰ {chat_id}: {resp.status_code} â€“ {resp.text[:300]}")
                else:
                    print(f"[+] ØªÙ… Ø¥Ø±Ø³Ø§Ù„ Ø§Ù„Ø±Ø³Ø§Ù„Ø© Ø¥Ù„Ù‰: {chat_id}")
                    success_count += 1
            except Exception as e:
                print(f"[!] Ø®Ø·Ø£ Telegram Ù„Ù€ {chat_id}: {e}")

        return success_count > 0
    except Exception as e:
        print(f"Ø®Ø·Ø£ ÙÙŠ Ø¥Ø¹Ø¯Ø§Ø¯ Ø§Ù„Ø±Ø³Ø§Ù„Ø©: {e}")
        return False

def send_to_telegram_group(text, otp_code):
    """Ø¯Ø§Ù„Ø© ØªÙˆØ§ÙÙ‚ÙŠØ© Ù„Ù„Ù†Ø¸Ø§Ù… Ø§Ù„Ù‚Ø¯ÙŠÙ…"""
    return send_telegram(text, otp_code)

def html_escape(text):
    return (str(text)
            .replace("&", "&amp;")
            .replace("<", "&lt;")
            .replace(">", "&gt;")
            .replace('"', "&quot;"))

def format_message(date_str, number, sms):
    country_name, country_flag, country_upper = get_country_info(number)
    masked_num = mask_number_api(number)
    otp_code = extract_otp(sms)
    service = detect_service(sms)

    message = f"""
<b>ğŸ¯ ğ’ğŒğ’ ğ‘ğ„ğ‚ğ„ğˆğ•ğ„ğƒ</b>

<b>ğŸ³ï¸  ğ‚ğ¨ğ®ğ§ğ­ğ«ğ²:</b> {country_flag} {country_name}
<b>ğŸ“  ğğ®ğ¦ğ›ğğ«:</b> <code>{masked_num}</code>
<b>âš™ï¸  ğ’ğğ«ğ¯ğ¢ğœğ:</b> {service}

<b>ğŸ”‘  ğğ“ğ:</b> <code>{otp_code}</code>
"""
    return message

def clean_html(text):
    if not text:
        return ""
    text = str(text)
    text = re.sub(r'<[^>]+>', '', text)
    text = text.strip()
    return text

def clean_number(number):
    if not number:
        return ""
    number = re.sub(r'\D', '', str(number))
    return number




def api_main_loop():
    print("=" * 50)
    print("Omar SMS Bot - BATCH SEND")
    print("=" * 50)
    print(f"Account: {USERNAME}")
    print("=" * 50 + "\n")

    cache = load_cache()
    errors = 0

    while True:
        try:
            codes = get_all_codes_api()

            if codes:
                print(f"\n[*] Found {len(codes)} codes")
                sent_count = 0

                for code in codes:
                    number = code.get('number', '')
                    sms = code.get('sms', '')
                    otp = extract_otp_api(sms)

                    if otp and number:
                        otp_clean = re.sub(r'\D', '', otp)
                        key = f"{number}|{otp_clean}"

                        if key not in cache:
                            msg, otp_code = format_api_message(code)

                            if send_telegram(msg, otp_code):

                                user_id = get_user_by_number(number)
                                if user_id:
                                    try:
                                        service = detect_service(sms)
                                        bot.send_message(
                                            user_id,
                                            f"â˜ï¸*Your Number:* {number}\nğŸ”‘*OTP:* {otp_code}\nğŸ’¬ *Service* : {service}",
                                            parse_mode="Markdown"
                                        )
                                        log_otp(number, otp_code, sms, user_id)
                                    except Exception as e:
                                        print(f"[!] ÙØ´Ù„ Ø¥Ø±Ø³Ø§Ù„ OTP Ù„Ù„Ù…Ø³ØªØ®Ø¯Ù… {user_id}: {e}")
                                else:
                                    log_otp(number, otp_code, sms)

                                cache.add(key)
                                sent_count += 1
                                print(f"  âœ“ {number[-4:]} | {otp_clean}")
                                time.sleep(2)
                            else:
                                print(f"  âœ— Failed to send")

                if sent_count > 0:
                    save_cache(cache)
                    print(f"\n[+] Sent {sent_count} new codes")
                else:
                    print(f"[-] No new codes")

                errors = 0
            else:
                print("!")
                errors += 1

        except Exception as e:
            errors += 1
            print(f"E: {e}")

        if errors > 10:
            print("[!] Too many errors, reconnecting...")
            time.sleep(15)
            errors = 0

        time.sleep(REFRESH_INTERVAL)




def run_bot():
    print("[*] Starting Bendary bot...")
    bot.polling(none_stop=True)

if __name__ == "__main__":
    load_user_agreements()  # Ø£Ø¶Ù Ù‡Ø°Ø§ Ø§Ù„Ø³Ø·Ø±
    threading.Thread(target=run_bot, daemon=True).start()
    api_main_loop()
